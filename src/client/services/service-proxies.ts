/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.20.0 (NJsonSchema v9.13.28.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class ServiceProxy {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:3000/api";
    }

    /**
     * Register user
     * @param body (optional) 
     * @return successful operation
     */
    registerUser(body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/auth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegisterUser(_response);
        });
    }

    protected processRegisterUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find permissions list of all modules
     * @return successful operation
     */
    findPermissions(): Promise<any> {
        let url_ = this.baseUrl + "/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindPermissions(_response);
        });
    }

    protected processFindPermissions(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * Check role name exist
     * @param roleName roleName
     * @return successful operation
     */
    checkRoleNameExist(roleName: string): Promise<CheckRoleNameExistResult> {
        let url_ = this.baseUrl + "/roles/customs/check-name-exist/{roleName}";
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckRoleNameExist(_response);
        });
    }

    protected processCheckRoleNameExist(response: Response): Promise<CheckRoleNameExistResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CheckRoleNameExistResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CheckRoleNameExistResult>(<any>null);
    }

    /**
     * Find all roles
     * @return successful operation
     */
    getAllRoles(): Promise<GetAllRolesResult> {
        let url_ = this.baseUrl + "/roles/customs/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRoles(_response);
        });
    }

    protected processGetAllRoles(response: Response): Promise<GetAllRolesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetAllRolesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetAllRolesResult>(<any>null);
    }

    /**
     * Find role by id
     * @param roleId roleId
     * @return successful operation
     */
    findRoleById(roleId: string): Promise<Role> {
        let url_ = this.baseUrl + "/roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindRoleById(_response);
        });
    }

    protected processFindRoleById(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Role>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(<any>null);
    }

    /**
     * Update role
     * @param roleId roleId
     * @param body (optional) 
     * @return successful operation
     */
    updateRole(roleId: string, body: any | undefined): Promise<Role> {
        let url_ = this.baseUrl + "/roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Role>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(<any>null);
    }

    /**
     * Find roles
     * @param search (optional) search
     * @param permissions (optional) filter by permissions
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findRoles(search: string | undefined, permissions: string[] | undefined, first: string, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindRolesResult> {
        let url_ = this.baseUrl + "/roles?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (permissions === null)
            throw new Error("The parameter 'permissions' cannot be null.");
        else if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "permissions=" + encodeURIComponent("" + item) + "&"; });
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindRoles(_response);
        });
    }

    protected processFindRoles(response: Response): Promise<FindRolesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindRolesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindRolesResult>(<any>null);
    }

    /**
     * Create role
     * @param body (optional) 
     * @return successful operation
     */
    createRole(body: any | undefined): Promise<Role> {
        let url_ = this.baseUrl + "/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Role>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(<any>null);
    }

    /**
     * Find profile
     * @return successful operation
     */
    findProfile(): Promise<User> {
        let url_ = this.baseUrl + "/profiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindProfile(_response);
        });
    }

    protected processFindProfile(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Find use profile for guess view
     * @param userId userId
     * @return successful operation
     */
    findPublicProfile(userId: string): Promise<User> {
        let url_ = this.baseUrl + "/profiles/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindPublicProfile(_response);
        });
    }

    protected processFindPublicProfile(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Update profile
     * @param userId userId
     * @param body (optional) 
     * @return successful operation
     */
    updateProfile(userId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/profiles/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProfile(_response);
        });
    }

    protected processUpdateProfile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find users
     * @param search (optional) search
     * @param roles (optional) filter by roles
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findUsers(search: string | undefined, roles: string[] | undefined, first: number, sortBy: string, before: number | undefined, after: number | undefined): Promise<FindUserResult> {
        let url_ = this.baseUrl + "/users?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (roles === null)
            throw new Error("The parameter 'roles' cannot be null.");
        else if (roles !== undefined)
            roles && roles.forEach(item => { url_ += "roles=" + encodeURIComponent("" + item) + "&"; });
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindUsers(_response);
        });
    }

    protected processFindUsers(response: Response): Promise<FindUserResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindUserResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindUserResult>(<any>null);
    }

    /**
     * Create user
     * @param body (optional) 
     * @return successful operation
     */
    createUser(body: any | undefined): Promise<User> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Check phone number exist
     * @param phoneNo phoneNo
     * @return successful operation
     */
    checkPhoneNoExist(phoneNo: string): Promise<CheckPhoneNoExistResult> {
        let url_ = this.baseUrl + "/users/customs/check-phone-number-exist/{phoneNo}";
        if (phoneNo === undefined || phoneNo === null)
            throw new Error("The parameter 'phoneNo' must be defined.");
        url_ = url_.replace("{phoneNo}", encodeURIComponent("" + phoneNo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckPhoneNoExist(_response);
        });
    }

    protected processCheckPhoneNoExist(response: Response): Promise<CheckPhoneNoExistResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CheckPhoneNoExistResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CheckPhoneNoExistResult>(<any>null);
    }

    /**
     * Check email exist
     * @param email email
     * @return successful operation
     */
    checkEmailExist(email: string): Promise<CheckEmailExistResult> {
        let url_ = this.baseUrl + "/users/customs/check-email-exist/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckEmailExist(_response);
        });
    }

    protected processCheckEmailExist(response: Response): Promise<CheckEmailExistResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CheckEmailExistResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CheckEmailExistResult>(<any>null);
    }

    /**
     * Find user by id
     * @param userId userId
     * @return successful operation
     */
    findUserById(userId: string): Promise<User> {
        let url_ = this.baseUrl + "/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindUserById(_response);
        });
    }

    protected processFindUserById(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Update user
     * @param userId userId
     * @param body (optional) 
     * @return successful operation
     */
    updateUser(userId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * update shop extend request
     * @param body (optional) 
     * @param requestId requestId
     * @return successful operation
     */
    updateShopExtendRequest(body: any | undefined, requestId: string): Promise<void> {
        let url_ = this.baseUrl + "/shop-extend-request/{requestId}";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateShopExtendRequest(_response);
        });
    }

    protected processUpdateShopExtendRequest(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get shop extend requests
     * @param search (optional) search string
     * @param state (optional) state
     * @param first limit size
     * @param sortBy order by
     * @param before (optional) before
     * @param after (optional) after
     * @return successful operation
     */
    getShopExtendRequests(search: string | undefined, state: string | undefined, first: number, sortBy: string, before: any | undefined, after: any | undefined): Promise<GetShopExtendRequestsResult> {
        let url_ = this.baseUrl + "/shop-extend-request?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetShopExtendRequests(_response);
        });
    }

    protected processGetShopExtendRequests(response: Response): Promise<GetShopExtendRequestsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetShopExtendRequestsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetShopExtendRequestsResult>(<any>null);
    }

    /**
     * Create extend request
     * @param body (optional) 
     * @return successful operation
     */
    createShopExtendRequest(body: any | undefined): Promise<ShopExtendRequest> {
        let url_ = this.baseUrl + "/shop-extend-request";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateShopExtendRequest(_response);
        });
    }

    protected processCreateShopExtendRequest(response: Response): Promise<ShopExtendRequest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShopExtendRequest>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <ShopExtendRequest>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShopExtendRequest>(<any>null);
    }

    /**
     * Get shop packages
     * @return successful operation
     */
    getShopPackages(): Promise<GetShopPackagesResult> {
        let url_ = this.baseUrl + "/shop-packages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetShopPackages(_response);
        });
    }

    protected processGetShopPackages(response: Response): Promise<GetShopPackagesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetShopPackagesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetShopPackagesResult>(<any>null);
    }

    /**
     * update adsense
     * @param adsenseId adsenseId
     * @param body (optional) 
     * @return successful operation
     */
    updateAdsense(adsenseId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/adsense/{adsenseId}";
        if (adsenseId === undefined || adsenseId === null)
            throw new Error("The parameter 'adsenseId' must be defined.");
        url_ = url_.replace("{adsenseId}", encodeURIComponent("" + adsenseId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAdsense(_response);
        });
    }

    protected processUpdateAdsense(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create adsense
     * @param body (optional) 
     * @return successful operation
     */
    createAdsense(body: any | undefined): Promise<Adsense> {
        let url_ = this.baseUrl + "/adsense";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateAdsense(_response);
        });
    }

    protected processCreateAdsense(response: Response): Promise<Adsense> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Adsense>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Adsense>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Adsense>(<any>null);
    }

    /**
     * Get adsense
     * @param first limit size
     * @param sortBy order by
     * @param before (optional) before
     * @param after (optional) after
     * @return successful operation
     */
    getAdsense(first: number, sortBy: string, before: any | undefined, after: any | undefined): Promise<GetAdsenseResult> {
        let url_ = this.baseUrl + "/adsense?";
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAdsense(_response);
        });
    }

    protected processGetAdsense(response: Response): Promise<GetAdsenseResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetAdsenseResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetAdsenseResult>(<any>null);
    }

    /**
     * update feature brand
     * @param featureBrandId featureBrandId
     * @param body (optional) 
     * @return successful operation
     */
    updateFeatureBrand(featureBrandId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/feature-brands/{featureBrandId}";
        if (featureBrandId === undefined || featureBrandId === null)
            throw new Error("The parameter 'featureBrandId' must be defined.");
        url_ = url_.replace("{featureBrandId}", encodeURIComponent("" + featureBrandId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateFeatureBrand(_response);
        });
    }

    protected processUpdateFeatureBrand(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get feature brands
     * @param first limit size
     * @param sortBy order by
     * @param before (optional) before
     * @param after (optional) after
     * @return successful operation
     */
    getFeatureBrands(first: number, sortBy: string, before: any | undefined, after: any | undefined): Promise<GetFeatureBrandsResult> {
        let url_ = this.baseUrl + "/feature-brands?";
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFeatureBrands(_response);
        });
    }

    protected processGetFeatureBrands(response: Response): Promise<GetFeatureBrandsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetFeatureBrandsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetFeatureBrandsResult>(<any>null);
    }

    /**
     * Create feature brand for ads
     * @param body (optional) 
     * @return successful operation
     */
    createFeatureBrand(body: any | undefined): Promise<FeatureBrand> {
        let url_ = this.baseUrl + "/feature-brands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFeatureBrand(_response);
        });
    }

    protected processCreateFeatureBrand(response: Response): Promise<FeatureBrand> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FeatureBrand>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <FeatureBrand>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FeatureBrand>(<any>null);
    }

    /**
     * Update rental period
     * @param rentalPeriodId rental period id
     * @param body (optional) 
     * @return successful operation
     */
    updateRentalPeriod(rentalPeriodId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/rental-periods/{rentalPeriodId}";
        if (rentalPeriodId === undefined || rentalPeriodId === null)
            throw new Error("The parameter 'rentalPeriodId' must be defined.");
        url_ = url_.replace("{rentalPeriodId}", encodeURIComponent("" + rentalPeriodId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRentalPeriod(_response);
        });
    }

    protected processUpdateRentalPeriod(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create rental period item
     * @param body (optional) 
     * @return successful operation
     */
    createRentalPeriod(body: any | undefined): Promise<RentalPeriod> {
        let url_ = this.baseUrl + "/rental-periods";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateRentalPeriod(_response);
        });
    }

    protected processCreateRentalPeriod(response: Response): Promise<RentalPeriod> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <RentalPeriod>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <RentalPeriod>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RentalPeriod>(<any>null);
    }

    /**
     * Get rental periods
     * @return successful operation
     */
    getAllRentalPeriods(): Promise<GetAllRentalPeriodsResult> {
        let url_ = this.baseUrl + "/rental-periods/customs/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRentalPeriods(_response);
        });
    }

    protected processGetAllRentalPeriods(response: Response): Promise<GetAllRentalPeriodsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetAllRentalPeriodsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetAllRentalPeriodsResult>(<any>null);
    }

    /**
     * Update weight range
     * @param weightRangeId weight range Id
     * @param body (optional) 
     * @return successful operation
     */
    updateWeightRange(weightRangeId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/weight-ranges/{weightRangeId}";
        if (weightRangeId === undefined || weightRangeId === null)
            throw new Error("The parameter 'weightRangeId' must be defined.");
        url_ = url_.replace("{weightRangeId}", encodeURIComponent("" + weightRangeId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWeightRange(_response);
        });
    }

    protected processUpdateWeightRange(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create weight range item
     * @param body (optional) 
     * @return successful operation
     */
    createWeightRange(body: any | undefined): Promise<WeightRange> {
        let url_ = this.baseUrl + "/weight-ranges";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWeightRange(_response);
        });
    }

    protected processCreateWeightRange(response: Response): Promise<WeightRange> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <WeightRange>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <WeightRange>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WeightRange>(<any>null);
    }

    /**
     * Get weight ranges
     * @return successful operation
     */
    getAllWeightRanges(): Promise<GetAllWeightRangesResult> {
        let url_ = this.baseUrl + "/weight-ranges/customs/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllWeightRanges(_response);
        });
    }

    protected processGetAllWeightRanges(response: Response): Promise<GetAllWeightRangesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetAllWeightRangesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetAllWeightRangesResult>(<any>null);
    }

    /**
     * Get common search keywords
     * @param first limit size
     * @param sortBy order by
     * @param before (optional) before
     * @param after (optional) after
     * @return successful operation
     */
    getCommonKeywords(first: number, sortBy: string, before: any | undefined, after: any | undefined): Promise<GetCommonKeywordsResult> {
        let url_ = this.baseUrl + "/common-keywords?";
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCommonKeywords(_response);
        });
    }

    protected processGetCommonKeywords(response: Response): Promise<GetCommonKeywordsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetCommonKeywordsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetCommonKeywordsResult>(<any>null);
    }

    /**
     * Create recent viewed item
     * @param body (optional) 
     * @return successful operation
     */
    createRecentViewed(body: any | undefined): Promise<RecentViewedItem> {
        let url_ = this.baseUrl + "/recent-viewed";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateRecentViewed(_response);
        });
    }

    protected processCreateRecentViewed(response: Response): Promise<RecentViewedItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <RecentViewedItem>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <RecentViewedItem>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RecentViewedItem>(<any>null);
    }

    /**
     * Get recent viewed items by users or uuid key
     * @param first limit size
     * @param sortBy order by
     * @param before (optional) before
     * @param after (optional) after
     * @return successful operation
     */
    getRecentViewed(first: number, sortBy: string, before: any | undefined, after: any | undefined): Promise<GetRecentViewedResult> {
        let url_ = this.baseUrl + "/recent-viewed?";
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRecentViewed(_response);
        });
    }

    protected processGetRecentViewed(response: Response): Promise<GetRecentViewedResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetRecentViewedResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetRecentViewedResult>(<any>null);
    }

    /**
     * Search news most follow
     * @param shopId (optional) shop Id
     * @param first limit size
     * @param sortBy order by
     * @param otherSortBy other order by
     * @param before (optional) before
     * @param after (optional) after
     * @return successful operation
     */
    searchNewsMostFollow(shopId: number | undefined, first: number, sortBy: string, otherSortBy: string, before: any | undefined, after: any | undefined): Promise<SearchNewsMostFollowResult> {
        let url_ = this.baseUrl + "/search-news-most-follow?";
        if (shopId === null)
            throw new Error("The parameter 'shopId' cannot be null.");
        else if (shopId !== undefined)
            url_ += "shopId=" + encodeURIComponent("" + shopId) + "&"; 
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (otherSortBy === undefined || otherSortBy === null)
            throw new Error("The parameter 'otherSortBy' must be defined and cannot be null.");
        else
            url_ += "otherSortBy=" + encodeURIComponent("" + otherSortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchNewsMostFollow(_response);
        });
    }

    protected processSearchNewsMostFollow(response: Response): Promise<SearchNewsMostFollowResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SearchNewsMostFollowResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchNewsMostFollowResult>(<any>null);
    }

    /**
     * Count unread notification
     * @param ownerId owner id
     * @return successful operation
     */
    countUnreadNotifications(ownerId: string): Promise<CountUnreadNotificationsResult> {
        let url_ = this.baseUrl + "/notifications/{ownerId}";
        if (ownerId === undefined || ownerId === null)
            throw new Error("The parameter 'ownerId' must be defined.");
        url_ = url_.replace("{ownerId}", encodeURIComponent("" + ownerId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountUnreadNotifications(_response);
        });
    }

    protected processCountUnreadNotifications(response: Response): Promise<CountUnreadNotificationsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CountUnreadNotificationsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountUnreadNotificationsResult>(<any>null);
    }

    /**
     * Read notifications
     * @param ownerId owner id
     * @param body (optional) 
     * @return successful operation
     */
    readNotifications(ownerId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/notifications/{ownerId}";
        if (ownerId === undefined || ownerId === null)
            throw new Error("The parameter 'ownerId' must be defined.");
        url_ = url_.replace("{ownerId}", encodeURIComponent("" + ownerId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReadNotifications(_response);
        });
    }

    protected processReadNotifications(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create notification
     * @param body (optional) 
     * @return successful operation
     */
    createNotification(body: any | undefined): Promise<Notification> {
        let url_ = this.baseUrl + "/notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateNotification(_response);
        });
    }

    protected processCreateNotification(response: Response): Promise<Notification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Notification>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Notification>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Notification>(<any>null);
    }

    /**
     * Find notifications
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findNotifications(first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindNotificationsResult> {
        let url_ = this.baseUrl + "/notifications?";
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindNotifications(_response);
        });
    }

    protected processFindNotifications(response: Response): Promise<FindNotificationsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindNotificationsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindNotificationsResult>(<any>null);
    }

    /**
     * Update report
     * @param reportId report id
     * @param body (optional) 
     * @return successful operation
     */
    updateReport(reportId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/reports/{reportId}";
        if (reportId === undefined || reportId === null)
            throw new Error("The parameter 'reportId' must be defined.");
        url_ = url_.replace("{reportId}", encodeURIComponent("" + reportId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateReport(_response);
        });
    }

    protected processUpdateReport(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find report by id
     * @param reportId report id
     * @return successful operation
     */
    findReportById(reportId: string): Promise<Report> {
        let url_ = this.baseUrl + "/reports/{reportId}";
        if (reportId === undefined || reportId === null)
            throw new Error("The parameter 'reportId' must be defined.");
        url_ = url_.replace("{reportId}", encodeURIComponent("" + reportId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindReportById(_response);
        });
    }

    protected processFindReportById(response: Response): Promise<Report> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Report>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Report>(<any>null);
    }

    /**
     * Create report
     * @param body (optional) 
     * @return successful operation
     */
    createReport(body: any | undefined): Promise<Report> {
        let url_ = this.baseUrl + "/reports";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateReport(_response);
        });
    }

    protected processCreateReport(response: Response): Promise<Report> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Report>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Report>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Report>(<any>null);
    }

    /**
     * Find reports
     * @param search (optional) state filter
     * @param state (optional) state filter
     * @param reason (optional) reason filter
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findReports(search: string | undefined, state: State | undefined, reason: Reason | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindReportsResult> {
        let url_ = this.baseUrl + "/reports?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (reason === null)
            throw new Error("The parameter 'reason' cannot be null.");
        else if (reason !== undefined)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&"; 
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindReports(_response);
        });
    }

    protected processFindReports(response: Response): Promise<FindReportsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindReportsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindReportsResult>(<any>null);
    }

    /**
     * Find shop by owner id
     * @param ownerId shop owner id
     * @return successful operation
     */
    findShopByOwner(ownerId: string): Promise<Shop> {
        let url_ = this.baseUrl + "/shop/get-by-owner/{ownerId}";
        if (ownerId === undefined || ownerId === null)
            throw new Error("The parameter 'ownerId' must be defined.");
        url_ = url_.replace("{ownerId}", encodeURIComponent("" + ownerId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindShopByOwner(_response);
        });
    }

    protected processFindShopByOwner(response: Response): Promise<Shop> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Shop>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Shop>(<any>null);
    }

    /**
     * Find shop by id
     * @param shopDomain shop domain
     * @param authId (optional) authUserId
     * @return successful operation
     */
    findShopByDomain(shopDomain: string, authId: string | undefined): Promise<Shop> {
        let url_ = this.baseUrl + "/shop/get-by-domain/{shopDomain}?";
        if (shopDomain === undefined || shopDomain === null)
            throw new Error("The parameter 'shopDomain' must be defined.");
        url_ = url_.replace("{shopDomain}", encodeURIComponent("" + shopDomain)); 
        if (authId === null)
            throw new Error("The parameter 'authId' cannot be null.");
        else if (authId !== undefined)
            url_ += "authId=" + encodeURIComponent("" + authId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindShopByDomain(_response);
        });
    }

    protected processFindShopByDomain(response: Response): Promise<Shop> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Shop>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Shop>(<any>null);
    }

    /**
     * Find news by id
     * @param shopId shop id
     * @return successful operation
     */
    findShopById(shopId: string): Promise<Shop> {
        let url_ = this.baseUrl + "/shop/{shopId}";
        if (shopId === undefined || shopId === null)
            throw new Error("The parameter 'shopId' must be defined.");
        url_ = url_.replace("{shopId}", encodeURIComponent("" + shopId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindShopById(_response);
        });
    }

    protected processFindShopById(response: Response): Promise<Shop> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Shop>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Shop>(<any>null);
    }

    /**
     * Update shop
     * @param shopId shop id
     * @param body (optional) 
     * @return successful operation
     */
    updateShop(shopId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/shop/{shopId}";
        if (shopId === undefined || shopId === null)
            throw new Error("The parameter 'shopId' must be defined.");
        url_ = url_.replace("{shopId}", encodeURIComponent("" + shopId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateShop(_response);
        });
    }

    protected processUpdateShop(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create shops
     * @param body (optional) 
     * @return successful operation
     */
    createShop(body: any | undefined): Promise<Shop> {
        let url_ = this.baseUrl + "/shop";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateShop(_response);
        });
    }

    protected processCreateShop(response: Response): Promise<Shop> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Shop>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Shop>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Shop>(<any>null);
    }

    /**
     * Find shops
     * @param search (optional) search query
     * @param isActive (optional) isActive filter
     * @param owner (optional) owner filter
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findShops(search: string | undefined, isActive: boolean | undefined, owner: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindShopsResult> {
        let url_ = this.baseUrl + "/shop?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (owner === null)
            throw new Error("The parameter 'owner' cannot be null.");
        else if (owner !== undefined)
            url_ += "owner=" + encodeURIComponent("" + owner) + "&"; 
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindShops(_response);
        });
    }

    protected processFindShops(response: Response): Promise<FindShopsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindShopsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindShopsResult>(<any>null);
    }

    /**
     * Find news by id
     * @param newsId newsId
     * @return successful operation
     */
    findNewsById(newsId: string): Promise<FindNewsDetail> {
        let url_ = this.baseUrl + "/news/{newsId}";
        if (newsId === undefined || newsId === null)
            throw new Error("The parameter 'newsId' must be defined.");
        url_ = url_.replace("{newsId}", encodeURIComponent("" + newsId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindNewsById(_response);
        });
    }

    protected processFindNewsById(response: Response): Promise<FindNewsDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindNewsDetail>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindNewsDetail>(<any>null);
    }

    /**
     * Update news
     * @param newsId newsId
     * @param body (optional) 
     * @return successful operation
     */
    updateNews(newsId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/news/{newsId}";
        if (newsId === undefined || newsId === null)
            throw new Error("The parameter 'newsId' must be defined.");
        url_ = url_.replace("{newsId}", encodeURIComponent("" + newsId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateNews(_response);
        });
    }

    protected processUpdateNews(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find news statistics for admin
     * @param startDate startDate
     * @param endDate endDate
     * @return successful operation
     */
    findNewsStatisticsInfo(startDate: string, endDate: string): Promise<NewsStatisticsResult> {
        let url_ = this.baseUrl + "/news/statistics/info?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "startDate=" + encodeURIComponent("" + startDate) + "&"; 
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "endDate=" + encodeURIComponent("" + endDate) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindNewsStatisticsInfo(_response);
        });
    }

    protected processFindNewsStatisticsInfo(response: Response): Promise<NewsStatisticsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <NewsStatisticsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NewsStatisticsResult>(<any>null);
    }

    /**
     * Find pending news for admin
     * @param keyword (optional) search keyword
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findPendingNews(keyword: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<ElasticSearchResult> {
        let url_ = this.baseUrl + "/news/customs/pending-news?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindPendingNews(_response);
        });
    }

    protected processFindPendingNews(response: Response): Promise<ElasticSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ElasticSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ElasticSearchResult>(<any>null);
    }

    /**
     * Find same owner news
     * @param newsId category
     * @param ownerId ownerId
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findSameOwnerNews(newsId: string, ownerId: string, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<ElasticSearchResult> {
        let url_ = this.baseUrl + "/news/customs/same-owner-news?";
        if (newsId === undefined || newsId === null)
            throw new Error("The parameter 'newsId' must be defined and cannot be null.");
        else
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&"; 
        if (ownerId === undefined || ownerId === null)
            throw new Error("The parameter 'ownerId' must be defined and cannot be null.");
        else
            url_ += "ownerId=" + encodeURIComponent("" + ownerId) + "&"; 
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindSameOwnerNews(_response);
        });
    }

    protected processFindSameOwnerNews(response: Response): Promise<ElasticSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ElasticSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ElasticSearchResult>(<any>null);
    }

    /**
     * Find related news
     * @param newsId category
     * @param owner owner id
     * @param category category
     * @param brand (optional) brand
     * @param model (optional) model
     * @param weightRange (optional) weightRange
     * @param shop (optional) shop
     * @param location (optional) location
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findRelatedNews(newsId: string, owner: string, category: string, brand: string | undefined, model: string | undefined, weightRange: string | undefined, shop: string | undefined, location: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<ElasticSearchResult> {
        let url_ = this.baseUrl + "/news/customs/related-news?";
        if (newsId === undefined || newsId === null)
            throw new Error("The parameter 'newsId' must be defined and cannot be null.");
        else
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&"; 
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined and cannot be null.");
        else
            url_ += "owner=" + encodeURIComponent("" + owner) + "&"; 
        if (category === undefined || category === null)
            throw new Error("The parameter 'category' must be defined and cannot be null.");
        else
            url_ += "category=" + encodeURIComponent("" + category) + "&"; 
        if (brand === null)
            throw new Error("The parameter 'brand' cannot be null.");
        else if (brand !== undefined)
            url_ += "brand=" + encodeURIComponent("" + brand) + "&"; 
        if (model === null)
            throw new Error("The parameter 'model' cannot be null.");
        else if (model !== undefined)
            url_ += "model=" + encodeURIComponent("" + model) + "&"; 
        if (weightRange === null)
            throw new Error("The parameter 'weightRange' cannot be null.");
        else if (weightRange !== undefined)
            url_ += "weightRange=" + encodeURIComponent("" + weightRange) + "&"; 
        if (shop === null)
            throw new Error("The parameter 'shop' cannot be null.");
        else if (shop !== undefined)
            url_ += "shop=" + encodeURIComponent("" + shop) + "&"; 
        if (location === null)
            throw new Error("The parameter 'location' cannot be null.");
        else if (location !== undefined)
            url_ += "location=" + encodeURIComponent("" + location) + "&"; 
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindRelatedNews(_response);
        });
    }

    protected processFindRelatedNews(response: Response): Promise<ElasticSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ElasticSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ElasticSearchResult>(<any>null);
    }

    /**
     * Find news by owner
     * @param ownerId ownerId
     * @param status news status
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findNewsByOwner(ownerId: string, status: string, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindNewsResultWithFollow> {
        let url_ = this.baseUrl + "/news/get-by-owner/{ownerId}?";
        if (ownerId === undefined || ownerId === null)
            throw new Error("The parameter 'ownerId' must be defined.");
        url_ = url_.replace("{ownerId}", encodeURIComponent("" + ownerId)); 
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined and cannot be null.");
        else
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindNewsByOwner(_response);
        });
    }

    protected processFindNewsByOwner(response: Response): Promise<FindNewsResultWithFollow> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindNewsResultWithFollow>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindNewsResultWithFollow>(<any>null);
    }

    /**
     * Find news
     * @param keyword (optional) search keyword
     * @param state (optional) product state (old/new)
     * @param priceType (optional) price type (fixed/negociate)
     * @param minPrice (optional) min price
     * @param maxPrice (optional) max price
     * @param newsType (optional) news type (sell/buy/...)
     * @param owner (optional) news owner id
     * @param shop (optional) shop id
     * @param location (optional) location (only by city)
     * @param type (optional) product type (may ui/may xuc/may dao)
     * @param brand (optional) product's brand
     * @param model (optional) product model
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findNews(keyword: string | undefined, state: string | undefined, priceType: string | undefined, minPrice: number | undefined, maxPrice: number | undefined, newsType: string | undefined, owner: string | undefined, shop: string | undefined, location: string | undefined, type: string | undefined, brand: string | undefined, model: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindNewsResult> {
        let url_ = this.baseUrl + "/news?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (priceType === null)
            throw new Error("The parameter 'priceType' cannot be null.");
        else if (priceType !== undefined)
            url_ += "priceType=" + encodeURIComponent("" + priceType) + "&"; 
        if (minPrice === null)
            throw new Error("The parameter 'minPrice' cannot be null.");
        else if (minPrice !== undefined)
            url_ += "minPrice=" + encodeURIComponent("" + minPrice) + "&"; 
        if (maxPrice === null)
            throw new Error("The parameter 'maxPrice' cannot be null.");
        else if (maxPrice !== undefined)
            url_ += "maxPrice=" + encodeURIComponent("" + maxPrice) + "&"; 
        if (newsType === null)
            throw new Error("The parameter 'newsType' cannot be null.");
        else if (newsType !== undefined)
            url_ += "newsType=" + encodeURIComponent("" + newsType) + "&"; 
        if (owner === null)
            throw new Error("The parameter 'owner' cannot be null.");
        else if (owner !== undefined)
            url_ += "owner=" + encodeURIComponent("" + owner) + "&"; 
        if (shop === null)
            throw new Error("The parameter 'shop' cannot be null.");
        else if (shop !== undefined)
            url_ += "shop=" + encodeURIComponent("" + shop) + "&"; 
        if (location === null)
            throw new Error("The parameter 'location' cannot be null.");
        else if (location !== undefined)
            url_ += "location=" + encodeURIComponent("" + location) + "&"; 
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (brand === null)
            throw new Error("The parameter 'brand' cannot be null.");
        else if (brand !== undefined)
            url_ += "brand=" + encodeURIComponent("" + brand) + "&"; 
        if (model === null)
            throw new Error("The parameter 'model' cannot be null.");
        else if (model !== undefined)
            url_ += "model=" + encodeURIComponent("" + model) + "&"; 
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindNews(_response);
        });
    }

    protected processFindNews(response: Response): Promise<FindNewsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindNewsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindNewsResult>(<any>null);
    }

    /**
     * Create news
     * @param body (optional) 
     * @return successful operation
     */
    createNews(body: any | undefined): Promise<News> {
        let url_ = this.baseUrl + "/news";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateNews(_response);
        });
    }

    protected processCreateNews(response: Response): Promise<News> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <News>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <News>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<News>(<any>null);
    }

    /**
     * Find brands
     * @param search (optional) search query to filter brands
     * @param first search query to filter brands
     * @param sortBy search query to filter brands
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findBrands(search: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindBrandsResult> {
        let url_ = this.baseUrl + "/brands?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindBrands(_response);
        });
    }

    protected processFindBrands(response: Response): Promise<FindBrandsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindBrandsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindBrandsResult>(<any>null);
    }

    /**
     * Create brand
     * @param body (optional) 
     * @return successful operation
     */
    createBrand(body: any | undefined): Promise<Brand> {
        let url_ = this.baseUrl + "/brands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateBrand(_response);
        });
    }

    protected processCreateBrand(response: Response): Promise<Brand> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Brand>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Brand>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Brand>(<any>null);
    }

    /**
     * Check existed brand
     * @param brandName brandName
     * @return successful operation
     */
    checkExistedBrand(brandName: string): Promise<CheckExistedBrandResult> {
        let url_ = this.baseUrl + "/brands/customs/check-existed-brand/{brandName}";
        if (brandName === undefined || brandName === null)
            throw new Error("The parameter 'brandName' must be defined.");
        url_ = url_.replace("{brandName}", encodeURIComponent("" + brandName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckExistedBrand(_response);
        });
    }

    protected processCheckExistedBrand(response: Response): Promise<CheckExistedBrandResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CheckExistedBrandResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CheckExistedBrandResult>(<any>null);
    }

    /**
     * Find brands list
     * @return successful operation
     */
    findBrandList(): Promise<FindBrandsResult> {
        let url_ = this.baseUrl + "/brands/customs/find-brand-list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindBrandList(_response);
        });
    }

    protected processFindBrandList(response: Response): Promise<FindBrandsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindBrandsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindBrandsResult>(<any>null);
    }

    /**
     * Find brand detail by slug
     * @param brandSlug brandSlug
     * @return successful operation
     */
    findBrandDetail(brandSlug: string): Promise<Brand> {
        let url_ = this.baseUrl + "/brands/customs/find-brand-detail/{brandSlug}";
        if (brandSlug === undefined || brandSlug === null)
            throw new Error("The parameter 'brandSlug' must be defined.");
        url_ = url_.replace("{brandSlug}", encodeURIComponent("" + brandSlug)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindBrandDetail(_response);
        });
    }

    protected processFindBrandDetail(response: Response): Promise<Brand> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Brand>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Brand>(<any>null);
    }

    /**
     * Find top brands
     * @return successful operation
     */
    findTopBrands(): Promise<FindBrandsResult> {
        let url_ = this.baseUrl + "/brands/customs/find-top-brands";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindTopBrands(_response);
        });
    }

    protected processFindTopBrands(response: Response): Promise<FindBrandsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindBrandsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindBrandsResult>(<any>null);
    }

    /**
     * Delete brand by id
     * @param brandId brandId
     * @return successful operation
     */
    deleteBrandById(brandId: string): Promise<void> {
        let url_ = this.baseUrl + "/brands/{brandId}";
        if (brandId === undefined || brandId === null)
            throw new Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteBrandById(_response);
        });
    }

    protected processDeleteBrandById(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find brand by id
     * @param brandId brandId
     * @return successful operation
     */
    findBrandById(brandId: string): Promise<Brand> {
        let url_ = this.baseUrl + "/brands/{brandId}";
        if (brandId === undefined || brandId === null)
            throw new Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindBrandById(_response);
        });
    }

    protected processFindBrandById(response: Response): Promise<Brand> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Brand>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Brand>(<any>null);
    }

    /**
     * Update brand
     * @param brandId brandId
     * @param body (optional) 
     * @return successful operation
     */
    updateBrand(brandId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/brands/{brandId}";
        if (brandId === undefined || brandId === null)
            throw new Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateBrand(_response);
        });
    }

    protected processUpdateBrand(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find categories
     * @return successful operation
     */
    findCategories(): Promise<FindCategoriesResult> {
        let url_ = this.baseUrl + "/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindCategories(_response);
        });
    }

    protected processFindCategories(response: Response): Promise<FindCategoriesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindCategoriesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindCategoriesResult>(<any>null);
    }

    /**
     * Create category
     * @param body (optional) 
     * @return successful operation
     */
    createCategory(body: any | undefined): Promise<Category> {
        let url_ = this.baseUrl + "/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCategory(_response);
        });
    }

    protected processCreateCategory(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Category>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Category>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category>(<any>null);
    }

    /**
     * Check existed category
     * @param categoryName categoryName
     * @return successful operation
     */
    checkExistedCategory(categoryName: string): Promise<CheckExistedCategoryResult> {
        let url_ = this.baseUrl + "/categories/customs/check-existed-category/{categoryName}";
        if (categoryName === undefined || categoryName === null)
            throw new Error("The parameter 'categoryName' must be defined.");
        url_ = url_.replace("{categoryName}", encodeURIComponent("" + categoryName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckExistedCategory(_response);
        });
    }

    protected processCheckExistedCategory(response: Response): Promise<CheckExistedCategoryResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CheckExistedCategoryResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CheckExistedCategoryResult>(<any>null);
    }

    /**
     * Find category detail by slug
     * @param categorySlug categorySlug
     * @return successful operation
     */
    findCategoryDetail(categorySlug: string): Promise<Category> {
        let url_ = this.baseUrl + "/categories/customs/find-category-detail/{categorySlug}";
        if (categorySlug === undefined || categorySlug === null)
            throw new Error("The parameter 'categorySlug' must be defined.");
        url_ = url_.replace("{categorySlug}", encodeURIComponent("" + categorySlug)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindCategoryDetail(_response);
        });
    }

    protected processFindCategoryDetail(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Category>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category>(<any>null);
    }

    /**
     * Find category by id
     * @param categoryId categoryId
     * @return successful operation
     */
    findCategoryById(categoryId: string): Promise<Category> {
        let url_ = this.baseUrl + "/categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindCategoryById(_response);
        });
    }

    protected processFindCategoryById(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Category>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category>(<any>null);
    }

    /**
     * Update category
     * @param categoryId categoryId
     * @param body (optional) 
     * @return successful operation
     */
    updateCategory(categoryId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCategory(_response);
        });
    }

    protected processUpdateCategory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete category by id
     * @param categoryId categoryId
     * @return successful operation
     */
    deleteCategoryById(categoryId: string): Promise<void> {
        let url_ = this.baseUrl + "/categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCategoryById(_response);
        });
    }

    protected processDeleteCategoryById(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find models
     * @param search (optional) search string
     * @param brand (optional) brand
     * @param category (optional) category
     * @param first search query to filter brands
     * @param sortBy search query to filter brands
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    findModels(search: string | undefined, brand: string | undefined, category: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindModelsResult> {
        let url_ = this.baseUrl + "/models?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (brand === null)
            throw new Error("The parameter 'brand' cannot be null.");
        else if (brand !== undefined)
            url_ += "brand=" + encodeURIComponent("" + brand) + "&"; 
        if (category === null)
            throw new Error("The parameter 'category' cannot be null.");
        else if (category !== undefined)
            url_ += "category=" + encodeURIComponent("" + category) + "&"; 
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindModels(_response);
        });
    }

    protected processFindModels(response: Response): Promise<FindModelsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindModelsResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindModelsResult>(<any>null);
    }

    /**
     * Create model
     * @param body (optional) 
     * @return successful operation
     */
    createModel(body: any | undefined): Promise<Model> {
        let url_ = this.baseUrl + "/models";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateModel(_response);
        });
    }

    protected processCreateModel(response: Response): Promise<Model> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Model>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Model>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Model>(<any>null);
    }

    /**
     * Check existed model
     * @param modelName modelName
     * @param brand brand id
     * @param category category id
     * @return successful operation
     */
    checkExistedModel(modelName: string, brand: string, category: string): Promise<CheckExistedModelResult> {
        let url_ = this.baseUrl + "/models/customs/check-existed-model/{modelName}?";
        if (modelName === undefined || modelName === null)
            throw new Error("The parameter 'modelName' must be defined.");
        url_ = url_.replace("{modelName}", encodeURIComponent("" + modelName)); 
        if (brand === undefined || brand === null)
            throw new Error("The parameter 'brand' must be defined and cannot be null.");
        else
            url_ += "brand=" + encodeURIComponent("" + brand) + "&"; 
        if (category === undefined || category === null)
            throw new Error("The parameter 'category' must be defined and cannot be null.");
        else
            url_ += "category=" + encodeURIComponent("" + category) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckExistedModel(_response);
        });
    }

    protected processCheckExistedModel(response: Response): Promise<CheckExistedModelResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CheckExistedModelResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CheckExistedModelResult>(<any>null);
    }

    /**
     * Delete model by id
     * @param modelId modelId
     * @return successful operation
     */
    deleteModelById(modelId: string): Promise<void> {
        let url_ = this.baseUrl + "/models/{modelId}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteModelById(_response);
        });
    }

    protected processDeleteModelById(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find model by id
     * @param modelId modelId
     * @return successful operation
     */
    findModelById(modelId: string): Promise<Model> {
        let url_ = this.baseUrl + "/models/{modelId}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindModelById(_response);
        });
    }

    protected processFindModelById(response: Response): Promise<Model> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Model>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Model>(<any>null);
    }

    /**
     * Update model
     * @param modelId modelId
     * @param body (optional) 
     * @return successful operation
     */
    updateModel(modelId: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/models/{modelId}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateModel(_response);
        });
    }

    protected processUpdateModel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find provinces
     * @return successful operation
     */
    findProvinces(): Promise<FindProvincesResult> {
        let url_ = this.baseUrl + "/provinces";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindProvinces(_response);
        });
    }

    protected processFindProvinces(response: Response): Promise<FindProvincesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FindProvincesResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindProvincesResult>(<any>null);
    }

    /**
     * Create province
     * @param body (optional) 
     * @return successful operation
     */
    createProvince(body: any | undefined): Promise<Province> {
        let url_ = this.baseUrl + "/provinces";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProvince(_response);
        });
    }

    protected processCreateProvince(response: Response): Promise<Province> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Province>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Province>JSON.parse(_responseText, this.jsonParseReviver);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Province>(<any>null);
    }

    /**
     * Find province by id
     * @param provinceId provinceId
     * @return successful operation
     */
    findProvinceById(provinceId: string): Promise<Province> {
        let url_ = this.baseUrl + "/provinces/{provinceId}";
        if (provinceId === undefined || provinceId === null)
            throw new Error("The parameter 'provinceId' must be defined.");
        url_ = url_.replace("{provinceId}", encodeURIComponent("" + provinceId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindProvinceById(_response);
        });
    }

    protected processFindProvinceById(response: Response): Promise<Province> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Province>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Province>(<any>null);
    }

    /**
     * Update province
     * @param province provinceId
     * @param body (optional) 
     * @return successful operation
     */
    updateProvince(province: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/provinces/{provinceId}";
        if (province === undefined || province === null)
            throw new Error("The parameter 'province' must be defined.");
        url_ = url_.replace("{province}", encodeURIComponent("" + province)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProvince(_response);
        });
    }

    protected processUpdateProvince(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Search by elasticsearch
     * @param keyword (optional) search keyword
     * @param state (optional) product state (old/new)
     * @param priceType (optional) price type (fixed/negociate)
     * @param minPrice (optional) min price
     * @param maxPrice (optional) max price
     * @param weightRange (optional) weight range
     * @param otherNewsType (optional) news type (sell/buy/...)
     * @param newsType (optional) news type (sell/buy/...)
     * @param categoryId (optional) categoryID
     * @param owner (optional) news owner id
     * @param shop (optional) shop id
     * @param location (optional) location (only by city)
     * @param type (optional) product type (may ui/may xuc/may dao)
     * @param brand (optional) product's brand
     * @param model (optional) product model
     * @param first number of records returned
     * @param sortBy sort field
     * @param before (optional) before token
     * @param after (optional) after token
     * @return successful operation
     */
    searchElasticsearch(keyword: string | undefined, state: string | undefined, priceType: string | undefined, minPrice: number | undefined, maxPrice: number | undefined, weightRange: string | undefined, otherNewsType: string | undefined, newsType: string | undefined, categoryId: string | undefined, owner: string | undefined, shop: string | undefined, location: string | undefined, type: string | undefined, brand: string | undefined, model: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<ElasticSearchResult> {
        let url_ = this.baseUrl + "/search?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (priceType === null)
            throw new Error("The parameter 'priceType' cannot be null.");
        else if (priceType !== undefined)
            url_ += "priceType=" + encodeURIComponent("" + priceType) + "&"; 
        if (minPrice === null)
            throw new Error("The parameter 'minPrice' cannot be null.");
        else if (minPrice !== undefined)
            url_ += "minPrice=" + encodeURIComponent("" + minPrice) + "&"; 
        if (maxPrice === null)
            throw new Error("The parameter 'maxPrice' cannot be null.");
        else if (maxPrice !== undefined)
            url_ += "maxPrice=" + encodeURIComponent("" + maxPrice) + "&"; 
        if (weightRange === null)
            throw new Error("The parameter 'weightRange' cannot be null.");
        else if (weightRange !== undefined)
            url_ += "weightRange=" + encodeURIComponent("" + weightRange) + "&"; 
        if (otherNewsType === null)
            throw new Error("The parameter 'otherNewsType' cannot be null.");
        else if (otherNewsType !== undefined)
            url_ += "otherNewsType=" + encodeURIComponent("" + otherNewsType) + "&"; 
        if (newsType === null)
            throw new Error("The parameter 'newsType' cannot be null.");
        else if (newsType !== undefined)
            url_ += "newsType=" + encodeURIComponent("" + newsType) + "&"; 
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&"; 
        if (owner === null)
            throw new Error("The parameter 'owner' cannot be null.");
        else if (owner !== undefined)
            url_ += "owner=" + encodeURIComponent("" + owner) + "&"; 
        if (shop === null)
            throw new Error("The parameter 'shop' cannot be null.");
        else if (shop !== undefined)
            url_ += "shop=" + encodeURIComponent("" + shop) + "&"; 
        if (location === null)
            throw new Error("The parameter 'location' cannot be null.");
        else if (location !== undefined)
            url_ += "location=" + encodeURIComponent("" + location) + "&"; 
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (brand === null)
            throw new Error("The parameter 'brand' cannot be null.");
        else if (brand !== undefined)
            url_ += "brand=" + encodeURIComponent("" + brand) + "&"; 
        if (model === null)
            throw new Error("The parameter 'model' cannot be null.");
        else if (model !== undefined)
            url_ += "model=" + encodeURIComponent("" + model) + "&"; 
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchElasticsearch(_response);
        });
    }

    protected processSearchElasticsearch(response: Response): Promise<ElasticSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ElasticSearchResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ElasticSearchResult>(<any>null);
    }

    /**
     * Search suggestion by elasticsearch
     * @param keyword search keyword
     * @return successful operation
     */
    searchSuggestions(keyword: string): Promise<SearchSuggestionResult> {
        let url_ = this.baseUrl + "/search-suggestions?";
        if (keyword === undefined || keyword === null)
            throw new Error("The parameter 'keyword' must be defined and cannot be null.");
        else
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchSuggestions(_response);
        });
    }

    protected processSearchSuggestions(response: Response): Promise<SearchSuggestionResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SearchSuggestionResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchSuggestionResult>(<any>null);
    }

    /**
     * Search by elasticsearch
     * @param keyword (optional) search keyword
     * @param state (optional) product state (old/new)
     * @param priceType (optional) price type (fixed/negociate)
     * @param minPrice (optional) min price
     * @param maxPrice (optional) max price
     * @param weightRange (optional) weight range
     * @param otherNewsType (optional) news type (sell/buy/...)
     * @param newsType (optional) news type (sell/buy/...)
     * @param categoryId (optional) categoryID
     * @param owner (optional) news owner id
     * @param shop (optional) shop id
     * @param location (optional) location (only by city)
     * @param type (optional) product type (may ui/may xuc/may dao)
     * @param brand (optional) product's brand
     * @param model (optional) product model
     * @param sortBy sort field
     * @param pageNumber page number
     * @param pageSize page size
     * @return successful operation
     */
    searchElasticsearchOffsetPaging(keyword: string | undefined, state: string | undefined, priceType: string | undefined, minPrice: number | undefined, maxPrice: number | undefined, weightRange: string | undefined, otherNewsType: string | undefined, newsType: string | undefined, categoryId: string | undefined, owner: string | undefined, shop: string | undefined, location: string | undefined, type: string | undefined, brand: string | undefined, model: string | undefined, sortBy: string, pageNumber: number, pageSize: number): Promise<ElasticSearchOffsetResult> {
        let url_ = this.baseUrl + "/search-offset?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (priceType === null)
            throw new Error("The parameter 'priceType' cannot be null.");
        else if (priceType !== undefined)
            url_ += "priceType=" + encodeURIComponent("" + priceType) + "&"; 
        if (minPrice === null)
            throw new Error("The parameter 'minPrice' cannot be null.");
        else if (minPrice !== undefined)
            url_ += "minPrice=" + encodeURIComponent("" + minPrice) + "&"; 
        if (maxPrice === null)
            throw new Error("The parameter 'maxPrice' cannot be null.");
        else if (maxPrice !== undefined)
            url_ += "maxPrice=" + encodeURIComponent("" + maxPrice) + "&"; 
        if (weightRange === null)
            throw new Error("The parameter 'weightRange' cannot be null.");
        else if (weightRange !== undefined)
            url_ += "weightRange=" + encodeURIComponent("" + weightRange) + "&"; 
        if (otherNewsType === null)
            throw new Error("The parameter 'otherNewsType' cannot be null.");
        else if (otherNewsType !== undefined)
            url_ += "otherNewsType=" + encodeURIComponent("" + otherNewsType) + "&"; 
        if (newsType === null)
            throw new Error("The parameter 'newsType' cannot be null.");
        else if (newsType !== undefined)
            url_ += "newsType=" + encodeURIComponent("" + newsType) + "&"; 
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&"; 
        if (owner === null)
            throw new Error("The parameter 'owner' cannot be null.");
        else if (owner !== undefined)
            url_ += "owner=" + encodeURIComponent("" + owner) + "&"; 
        if (shop === null)
            throw new Error("The parameter 'shop' cannot be null.");
        else if (shop !== undefined)
            url_ += "shop=" + encodeURIComponent("" + shop) + "&"; 
        if (location === null)
            throw new Error("The parameter 'location' cannot be null.");
        else if (location !== undefined)
            url_ += "location=" + encodeURIComponent("" + location) + "&"; 
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (brand === null)
            throw new Error("The parameter 'brand' cannot be null.");
        else if (brand !== undefined)
            url_ += "brand=" + encodeURIComponent("" + brand) + "&"; 
        if (model === null)
            throw new Error("The parameter 'model' cannot be null.");
        else if (model !== undefined)
            url_ += "model=" + encodeURIComponent("" + model) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchElasticsearchOffsetPaging(_response);
        });
    }

    protected processSearchElasticsearchOffsetPaging(response: Response): Promise<ElasticSearchOffsetResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ElasticSearchOffsetResult>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ElasticSearchOffsetResult>(<any>null);
    }

    /**
     * Follow
     * @param id newsId
     * @param body (optional) 
     * @return successful operation
     */
    follow(id: string, body: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/follows/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFollow(_response);
        });
    }

    protected processFollow(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find follow by user/news
     * @param id id
     * @param type type
     * @param newsType (optional) type
     * @param first first
     * @param sortBy sortBy
     * @param before (optional) before
     * @param after (optional) after
     * @return successful operation
     */
    findFollow(id: string, type: string, newsType: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<any> {
        let url_ = this.baseUrl + "/follows?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (newsType === null)
            throw new Error("The parameter 'newsType' cannot be null.");
        else if (newsType !== undefined)
            url_ += "newsType=" + encodeURIComponent("" + newsType) + "&"; 
        if (first === undefined || first === null)
            throw new Error("The parameter 'first' must be defined and cannot be null.");
        else
            url_ += "first=" + encodeURIComponent("" + first) + "&"; 
        if (sortBy === undefined || sortBy === null)
            throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
        else
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&"; 
        if (before === null)
            throw new Error("The parameter 'before' cannot be null.");
        else if (before !== undefined)
            url_ += "before=" + encodeURIComponent("" + before) + "&"; 
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindFollow(_response);
        });
    }

    protected processFindFollow(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }
}

export interface GetAllRolesResult {
    roles: Role[];
}

export interface CheckPhoneNoExistResult {
    phoneNoExist: boolean;
}

export interface CheckRoleNameExistResult {
    roleNameExist: boolean;
}

export interface RegisterUserPayload {
    idToken: string;
}

export interface FindRolesResult {
    data: Role[];
    before: any;
    after: any;
}

export interface ActivateRolePayload {
    operation: ActivateRolePayloadOperation;
}

export interface DeactivateRolePayload {
    operation: DeactivateRolePayloadOperation;
}

export interface UpdateRolePayload {
    operation: UpdateRolePayloadOperation;
    payload: Payload;
}

export interface Role {
    _id: string;
    name: string;
    description: string;
    permissions: string[];
}

export interface CreateRolePayload {
    name: string;
    description: string;
    permissions: string[];
}

export interface FindUserResult {
    data: User[];
    before: any;
    after: any;
    roles: any[];
    completeSignUp: boolean;
    isActive: boolean;
    isDeleted: boolean;
    lastModifiedAt: any;
    _id: string;
    permissions: any[];
    email: string;
    createdBy: string;
    createdAt: any;
    followBy: any[];
}

export interface FacebookLogin {
    uid: string;
    email: string;
    provider: FacebookLoginProvider;
}

export interface GoogleLogin {
    uid: string;
    email: string;
    provider: GoogleLoginProvider;
}

export interface PhoneLogin {
    phoneNo: string;
    provider: PhoneLoginProvider;
}

export interface EmailLogin {
    email: string;
    provider: EmailLoginProvider;
}

export interface User {
    _id: string;
    email: string;
    familyName: string;
    givenName: string;
    fullName: string;
    phoneNo: string;
    address: string;
    description: string;
    avatarUrl: string;
    province: string;
    dob: number;
    gender: string;
    loginDetail: any;
    roles: string[];
    completeSignUp: boolean;
    followBy: any[];
    isActive: boolean;
    createdAt: number;
    createdBy: number;
    counterFollow: number;
    isFollowing: boolean;
}

export interface CheckEmailExistResult {
    emailExist: boolean;
}

export interface UpdateUserPayload {
    operation: UpdateUserPayloadOperation;
    payload: Payload2;
}

export interface UpdateProfilePayload {
    operation: UpdateProfilePayloadOperation;
    payload: Payload3;
}

export interface ChangePasswordPayload {
    newPassword: string;
}

export interface ActivateUserPayload {
    operation: ActivateUserPayloadOperation;
}

export interface DeactivateUserPayload {
    operation: DeactivateUserPayloadOperation;
}

export interface UpdateAvatarPayload {
    operation: UpdateAvatarPayloadOperation;
    data: Data;
}

export interface CreateUserPayload {
    email: string;
    password: string;
    roles: string[];
    familyName: string;
    givenName: string;
}

export interface FollowUser {
    _id: string;
    followee: any;
    user: any;
    createdAt: number;
}

export interface FollowShop {
    _id: string;
    shop: any;
    user: any;
    createdAt: number;
}

export interface SearchSuggestionResult {
    suggestions: string[];
}

export interface CreateNotificationPayload {
    owner: string;
    news: string;
    report: string;
    description: string;
    state: string;
    type: string;
}

export interface UpdateShopExtendRequestPayload {
    operation: string;
    payload: any;
}

export interface ShopExtendRequestPayload {
    shop: string;
    package: string;
}

export interface ShopExtendRequest {
    _id: string;
    package: any;
    shop: any;
    shopName: string;
    state: string;
    requestedAt: number;
    requestedBy: any;
    extendedAt: number;
    extendedBy: any;
}

export interface GetShopExtendRequestsResult {
    data: ShopExtendRequest[];
    before: string;
    after: string;
}

export interface ShopPackage {
    _id: string;
    price: number;
    currency: string;
    monthDuration: number;
    isActive: boolean;
    createdAt: number;
}

export interface GetShopPackagesResult {
    data: ShopPackage[];
}

export interface CheckExistedModelResult {
    existedModel: boolean;
}

export interface CheckExistedCategoryResult {
    existedCategory: boolean;
}

export interface CheckExistedBrandResult {
    existedBrand: boolean;
}

export interface NewsStatisticsResult {
    daysOfWeek: DaysOfWeek[];
    hoursOfDay: HoursOfDay[];
    brands: Brand[];
    categories: Category[];
    provinces: Province[];
}

export interface UpdateAdsensePayload {
    operation: UpdateAdsensePayloadOperation;
    payload: Payload4;
}

export interface CreateAdsensePayload {
    name: string;
    imageUrl: string;
    hyperlink: string;
    position: number;
}

export interface GetAdsenseResult {
    data: Adsense[];
}

export interface Adsense {
    _id: string;
    name: string;
    imageUrl: string;
    hyperlink: string;
    position: number;
    createdAt: number;
}

export interface UpdateFeatureBrandPayload {
    operation: UpdateFeatureBrandPayloadOperation;
    payload: Payload5;
}

export interface GetFeatureBrandsResult {
    data: FeatureBrand[];
    before: string;
    after: string;
}

export interface CreateFeatureBrandPayload {
    brand: string;
    logoImage: string;
    hyperlink: string;
    order: number;
}

export interface FeatureBrand {
    _id: string;
    brand: any;
    logoImage: string;
    hyperlink: string;
    order: number;
    createdAt: number;
}

export interface CreateRentalPeriodPayload {
    min: number;
    max: number;
}

export interface UpdateRentalPeriodPayload {
    operation: UpdateRentalPeriodPayloadOperation;
    payload: Payload6;
}

export interface UpdateWeightRangePayload {
    operation: UpdateWeightRangePayloadOperation;
    payload: Payload7;
}

export interface CreateWeightRangePayload {
    min: number;
    max: number;
}

export interface RentalPeriod {
    _id: string;
    min: number;
    max: number;
    createdAt: number;
}

export interface GetAllRentalPeriodsResult {
    data: RentalPeriod[];
}

export interface WeightRange {
    _id: string;
    min: number;
    max: number;
    createdAt: number;
}

export interface GetAllWeightRangesResult {
    data: WeightRange[];
}

export interface CommonKeyword {
    keyword: string;
    count: number;
    createdAt: number;
}

export interface GetCommonKeywordsResult {
    data: CommonKeyword[];
    before: string;
    after: string;
}

export interface CreateRecentViewedPayload {
    news: string;
}

export interface RecentViewedItem {
    _id: string;
    uuid: string;
    user: string;
    news: any;
    createdAt: number;
    lastModifiedAt: number;
}

export interface GetRecentViewedResult {
    data: RecentViewedItem[];
    before: string;
    after: string;
}

export interface SearchNewsMostFollowResult {
    data: SearchNewsMostFollowItemResult[];
    before: string;
    after: string;
}

export interface ReadNotificationPayload {
    operation: ReadNotificationPayloadOperation;
    payload: Payload8;
}

export interface ReadAllNotificationsPayload {
    operation: ReadAllNotificationsPayloadOperation;
}

export interface CountUnreadNotificationsResult {
    unreadNotifications: number;
}

export interface Notification {
    _id: string;
    owner: any;
    news: any;
    report: any;
    description: string;
    state: NotificationState;
    type: NotificationType;
    createdAt: number;
}

export interface FindNotificationsResult {
    data: Notification[];
    before: string;
    after: string;
}

export interface SearchNewsMostFollowItemResult {
    _id: string;
    imageUrls: string[];
    isDeleted: boolean;
    lastModifiedAt: number;
    isFollowing: boolean;
    title: string;
    state: string;
    newsType: string;
    counterFollow: number;
    counterView: number;
}

export interface FindReportsResult {
    data: Report[];
    before: string;
    after: string;
}

export interface UpdateReportPayload {
    operation: UpdateReportPayloadOperation;
    payload: Payload9;
}

export interface Report {
    _id: any;
    news: any;
    reports: Reports[];
    state: ReportState;
    resolvedResult: ReportResolvedResult;
    resolvedBy: any;
    resolvedAt: number;
}

export interface CreateReportPayload {
    news: string;
    reason: CreateReportPayloadReason;
    description: string;
    email: string;
    phoneNo: string;
}

export interface UpdateIntroImagesShopPayload {
    operation: UpdateIntroImagesShopPayloadOperation;
    payload: Payload10;
}

export interface UpdateLogoImageShopPayload {
    operation: UpdateLogoImageShopPayloadOperation;
    payload: Payload11;
}

export interface DeactivateShopPayload {
    operation: DeactivateShopPayloadOperation;
}

export interface ActivateShopPayload {
    operation: ActivateShopPayloadOperation;
}

export interface UpdateShopPayload {
    operation: UpdateShopPayloadOperation;
    payload: Payload12;
}

export interface CreateShopPayload {
    owner: string;
    domain: string;
    name: string;
    email: string;
    address: string;
    geocode: Geocode;
    description: string;
    phone: string;
    representative: Representative;
    introImages: string[];
    logoImage: string;
}

export interface FindShopsResult {
    data: Shop[];
    before: string;
    after: string;
}

export interface Shop {
    _id: string;
    isActive: boolean;
    expiryDate: number;
    purchasedPackages: number[];
    createdAt: number;
    owner: any;
    domain: string;
    name: string;
    address: string;
    geocode: Geocode2;
    description: string;
    isFollowing: boolean;
    phone: string;
    email: string;
    representative: Representative2;
    introImages: string[];
    logoImage: string;
}

export interface ElasticSearchResult {
    data: ElasticSearchItemResult[];
    before: string;
    after: string;
}

export interface ElasticSearchOffsetResult {
    data: ElasticSearchItemResult[];
    total: number;
}

export interface ElasticSearchItemResult {
    title: string;
    state: string;
    description: string;
    shop: any;
    imageUrls: string[];
    price: number;
    priceType: string;
    newsType: string;
    owner: any;
    location: Location;
    status: string;
    usedHours: number;
    serialNo: number;
    categoryId: CategoryId;
    brand: Brand2;
    model: Model2;
    weight: number;
    year: number;
    followBy: string[];
    isDeleted: boolean;
    createdBy: number;
    createdAt: number;
    lastModifiedAt: number;
    elasticsearchID: string;
    elasticsearchTitle: string;
    isFollowing: boolean;
    _id: string;
}

export interface News {
    _id: string;
    title: string;
    state: string;
    description: string;
    imageUrls: string[];
    price: number;
    priceType: string;
    newsType: string;
    owner: any;
    shop: any;
    location: any;
    status: string;
    usedHours: number;
    serialNo: string;
    categoryId: any;
    type: any;
    brand: any;
    model: any;
    weight: number;
    year: number;
    weightRange: any;
    rentalPeriod: any;
    followBy: any[];
    isFollowing: boolean;
    createdAt: number;
    counterFollow: number;
    counterView: number;
}

export interface FindNewsDetail {
    _id: string;
    title: string;
    state: string;
    description: string;
    imageUrls: string[];
    price: number;
    priceType: string;
    newsType: string;
    owner: any;
    shop: any;
    location: any;
    status: string;
    usedHours: number;
    serialNo: string;
    categoryId: any;
    type: any;
    brand: any;
    model: any;
    weight: number;
    year: number;
    weightRange: any;
    rentalPeriod: any;
    followBy: any[];
    isFollowing: boolean;
    createdAt: number;
    counterView: number;
    counterFollow: number;
}

export interface CreateNewsPayload {
    title: string;
    state: string;
    newsType: string;
    priceType: string;
    location: string;
    owner: string;
    status: string;
    usedHours: number;
    serialNo: string;
    categoryId: string;
    type: string;
    brand: string;
    model: string;
    weight: number;
    year: number;
}

export interface UpdateNewsPayload {
    operation: string;
    data: Data2;
}

export interface FindNewsResult {
    data: News[];
    before: string;
    after: string;
}

export interface FindNewsResultWithFollow {
    data: FindNewsDetail[];
    before: string;
    after: string;
}

export interface Brand {
    _id: string;
    slug: string;
    name: string;
    logoImage: string;
    totalNews: number;
    brandCategories: Category[];
    brandModels: Model[];
    createdAt: number;
}

export interface FindBrandsResult {
    data: Brand[];
    before: string;
    after: string;
}

export interface CreateBrandPayload {
    name: string;
    logoImage: string;
}

export interface UpdateBrandPayload {
    operation: UpdateBrandPayloadOperation;
    payload: any;
}

export interface Category {
    _id: string;
    slug: string;
    name: string;
    imageUrl: string;
    totalNews: number;
    categoryBrands: Brand[];
    categoryModels: Model[];
    createdAt: number;
}

export interface FindCategoriesResult {
    data: Category[];
}

export interface CreateCategoryPayload {
    name: string;
    imageUrl: string;
}

export interface UpdateCategoryPayload {
    operation: UpdateCategoryPayloadOperation;
    payload: Payload13;
}

export interface Model {
    _id: string;
    slug: string;
    name: string;
    brand: any;
    category: any;
    totalNews: number;
    createdAt: number;
}

export interface FindModelsResult {
    data: Model[];
    before: string;
    after: string;
}

export interface CreateModelPayload {
    name: string;
    slug: string;
    brand: string;
    model: string;
}

export interface UpdateModelPayload {
    _id: string;
    name: string;
    slug: string;
    brand: string;
    model: string;
}

export interface Province {
    _id: string;
    slug: string;
    name: string;
    totalNews: number;
}

export interface FindProvincesResult {
    data: Province[];
}

export interface CreateProvincePayload {
    name: string;
    slug: string;
}

export interface UpdateProvincePayload {
    _id: string;
    name: string;
    slug: string;
}

export interface FollowPayload {
    operation: string;
    payload: Payload14;
}

export interface FindUserFollowResult {
    data: FindUserResult[];
}

export enum State {
    PENDING = "PENDING", 
    RESOLVED = "RESOLVED", 
}

export enum Reason {
    WRONG_INFO = "WRONG_INFO", 
    SOLD = "SOLD", 
    VIOLATE = "VIOLATE", 
}

export enum ActivateRolePayloadOperation {
    Activate = "activate", 
}

export enum DeactivateRolePayloadOperation {
    Deactivate = "deactivate", 
}

export enum UpdateRolePayloadOperation {
    UpdateDetail = "updateDetail", 
}

export interface Payload {
    name: string;
    description: string;
    permissions: string[];
}

export enum FacebookLoginProvider {
    Facebook = "facebook", 
}

export enum GoogleLoginProvider {
    Google = "google", 
}

export enum PhoneLoginProvider {
    Phone = "phone", 
}

export enum EmailLoginProvider {
    Email = "email", 
}

export enum UpdateUserPayloadOperation {
    UpdateDetail = "updateDetail", 
}

export interface Payload2 {
    roles: string[];
    familyName: string;
    givenName: string;
    email: string;
}

export enum UpdateProfilePayloadOperation {
    UpdateDetail = "updateDetail", 
}

export interface Payload3 {
    familyName: string;
    givenName: string;
    phoneNo: string;
    email: string;
    address: string;
    description: string;
}

export enum ActivateUserPayloadOperation {
    Activate = "activate", 
}

export enum DeactivateUserPayloadOperation {
    Deactivate = "deactivate", 
}

export enum UpdateAvatarPayloadOperation {
    UpdateAvatar = "updateAvatar", 
}

export interface Data {
    avatarUrl: string;
}

export interface DaysOfWeek {
    _id: number;
    totalNews: number;
}

export interface HoursOfDay {
    _id: number;
    totalNews: number;
}

export enum UpdateAdsensePayloadOperation {
    UpdateDetail = "updateDetail", 
}

export interface Payload4 {
    name: string;
    imageUrl: string;
    hyperlink: string;
    position: number;
}

export enum UpdateFeatureBrandPayloadOperation {
    UpdateDetail = "updateDetail", 
}

export interface Payload5 {
    brand: string;
    logoImage: string;
    hyperlink: string;
    order: number;
}

export enum UpdateRentalPeriodPayloadOperation {
    UpdateDetail = "updateDetail", 
}

export interface Payload6 {
    min: number;
    max: number;
}

export enum UpdateWeightRangePayloadOperation {
    UpdateDetail = "updateDetail", 
}

export interface Payload7 {
    min: number;
    max: number;
}

export enum ReadNotificationPayloadOperation {
    ReadNotification = "readNotification", 
}

export interface Payload8 {
    notificationId: string;
}

export enum ReadAllNotificationsPayloadOperation {
    ReadAllNotifications = "readAllNotifications", 
}

export enum NotificationState {
    READ = "READ", 
    UNREAD = "UNREAD", 
}

export enum NotificationType {
    FOLLOW_USER = "FOLLOW_USER", 
    FOLLOW_SHOP = "FOLLOW_SHOP", 
    CREATE_NEWS = "CREATE_NEWS", 
    DELETE_NEWS = "DELETE_NEWS", 
    WARN_NEWS = "WARN_NEWS", 
}

export enum UpdateReportPayloadOperation {
    ResolveReport = "resolveReport", 
}

export interface Payload9 {
    resolvedResult: Payload9ResolvedResult;
}

export interface Reports {
    reason: ReportsReason;
    description: string;
    createdBy: any;
    createdAt: number;
}

export enum ReportState {
    PENDING = "PENDING", 
    RESOLVED = "RESOLVED", 
}

export enum ReportResolvedResult {
    SKIP = "SKIP", 
    DELETE = "DELETE", 
    NOTIFY = "NOTIFY", 
}

export enum CreateReportPayloadReason {
    WRONG_INFO = "WRONG_INFO", 
    SOLD = "SOLD", 
    VIOLATE = "VIOLATE", 
}

export enum UpdateIntroImagesShopPayloadOperation {
    UpdateCover = "updateCover", 
}

export interface Payload10 {
    introImages: string[];
}

export enum UpdateLogoImageShopPayloadOperation {
    UpdateAvatar = "updateAvatar", 
}

export interface Payload11 {
    logoImage: string;
}

export enum DeactivateShopPayloadOperation {
    Deactivate = "deactivate", 
}

export enum ActivateShopPayloadOperation {
    Activate = "activate", 
}

export enum UpdateShopPayloadOperation {
    UpdateDetail = "updateDetail", 
}

export interface Payload12 {
    domain: string;
    name: string;
    address: string;
    geocode: Geocode3;
    phone: string;
    email: string;
    introImages: string[];
    logoImage: string;
    representative: Representative3;
}

export interface Geocode {
    lng: number;
    lat: number;
}

export interface Representative {
    fullName: string;
    identityNumber: string;
    email: string;
    paymentPhoneNo: string;
    address: string;
}

export interface Geocode2 {
    lng: number;
    lat: number;
}

export interface Representative2 {
    fullName: string;
    identityNumber: string;
    email: string;
    paymentPhoneNo: string;
    address: string;
}

export interface Location {
    isDeleted: boolean;
    lastModifiedAt: number;
    _id: string;
    name: string;
    slug: string;
}

export interface CategoryId {
    isDeleted: boolean;
    lastModifiedAt: number;
    _id: string;
    name: string;
    slug: string;
}

export interface Brand2 {
    isDeleted: boolean;
    lastModifiedAt: number;
    _id: string;
    name: string;
    slug: string;
    totalNews: number;
}

export interface Model2 {
    isDeleted: boolean;
    lastModifiedAt: number;
    _id: string;
    name: string;
    slug: string;
    brand: string;
    category: string;
}

export interface Data2 {
    title: string;
    state: string;
    newsType: string;
    priceType: string;
    location: string;
    owner: string;
    status: string;
    usedHours: number;
    serialNo: string;
    categoryId: string;
    type: string;
    brand: string;
    model: string;
    weight: number;
    year: number;
}

export enum UpdateBrandPayloadOperation {
    UpdateDetail = "updateDetail", 
}

export enum UpdateCategoryPayloadOperation {
    UdpateDetail = "udpateDetail", 
}

export interface Payload13 {
    name: string;
    imageUrl: string;
}

export interface Payload14 {
    userId: string;
    newsId: string;
}

export enum Payload9ResolvedResult {
    SKIP = "SKIP", 
    DELETE = "DELETE", 
    NOTIFY = "NOTIFY", 
}

export enum ReportsReason {
    WRONG_INFO = "WRONG_INFO", 
    SOLD = "SOLD", 
    VIOLATE = "VIOLATE", 
}

export interface Geocode3 {
    lng: number;
    lat: number;
}

export interface Representative3 {
    fullName: string;
    identityNumber: string;
    email: string;
    paymentPhoneNo: string;
    address: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}