{"version":3,"file":"static/development/pages/refresh-token-iframe.js","sources":["webpack:///webpack/bootstrap","webpack:///./config/default.config.ts","webpack:///./config/index.ts","webpack:///./config/override.config.ts","webpack:///./core/checkFollowStatus.ts","webpack:///./core/checkIsMobile.ts","webpack:///./core/checkPermission.ts","webpack:///./core/checkSubdomain.ts","webpack:///./core/clearCookie.ts","webpack:///./core/constants.ts","webpack:///./core/convertVietnamese.ts","webpack:///./core/firebase.ts","webpack:///./core/formatter.ts","webpack:///./core/generateFilters.ts","webpack:///./core/generateRecentViewedKey.ts","webpack:///./core/generateSearchUrl.ts","webpack:///./core/getBase64Image.ts","webpack:///./core/getImageUrl.ts","webpack:///./core/getMenuConfigs.ts","webpack:///./core/getShopUrl.ts","webpack:///./core/index.ts","webpack:///./core/metadata.ts","webpack:///./core/setCookie.ts","webpack:///./core/submitLoginForm.ts","webpack:///./core/validateField.ts","webpack:///./modules/admin/menuConfigs.ts","webpack:///./pages/refresh-token-iframe.tsx","webpack:///./services/index.ts","webpack:///./services/service-proxies.ts","webpack:///external \"@babel/runtime/regenerator\"","webpack:///external \"firebase/app\"","webpack:///external \"firebase/auth\"","webpack:///external \"isomorphic-fetch\"","webpack:///external \"react\"","webpack:///external \"uuid\""],"sourcesContent":[" \t// The module cache\n \tvar installedModules = require('../../../ssr-module-cache.js');\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tvar threw = true;\n \t\ttry {\n \t\t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n \t\t\tthrew = false;\n \t\t} finally {\n \t\t\tif(threw) delete installedModules[moduleId];\n \t\t}\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","import { overrideConfig } from './override.config';\n\nexport const config = {\n  appName: '',\n  firebase: {\n    apiKey: '',\n    authDomain: '',\n    databaseURL: '',\n    projectId: '',\n    storageBucket: '',\n    messagingSenderId: '',\n  },\n  url: {\n    main: '',\n    api: '',\n    shop: '',\n  },\n  i18n: {\n    VN: 'vn',\n    EN: 'en',\n    defaultLang: 'vn',\n  },\n  upload: {\n    allowImageExt: /\\.(gif|jpg|jpeg|tiff|png|JPG|PNG|JPEG|GIF|TIFF)$/,\n    allowExcelExt: /\\.(csv|xls|xlsm|xlsx|xml|xlsb|xlam)$/,\n    shopIntroImageNumber: 10,\n  },\n  googleMaps: {\n    apiKey: 'AIzaSyBWcb9PYE2yddvlnN53fB76Y1XSfjURHFk', // 'AIzaSyCvrUsYnz-hSv0rZF3zAx7gx98uz4O-bvM',\n  },\n  cookies: {\n    domain: '',\n    maxAge: 0,\n  },\n  regex: {\n    password: /^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{6,}$/,\n    email: /^[a-z][a-z0-9_\\.]{5,40}@[a-z0-9]{2,}(\\.[a-z0-9]{2,4}){1,2}$/,\n    phone: /^([+]*[(]{0,1}[0-9]{1,4}[)]{0,1}[-\\s\\./0-9]*){8,}$/,\n  },\n  ...overrideConfig,\n};\n","export * from './default.config';\n","export const overrideConfig = {\n  appName: 'excado-develop',\n  facebookAppId: '329120894475942',\n  firebase: {\n    apiKey: 'AIzaSyDaNVSsb66VTC7olY2VuAiKmO-J5e_PDYM',\n    authDomain: 'techkids-ac7a7.firebaseapp.com',\n    databaseURL: 'https://techkids-ac7a7.firebaseio.com',\n    projectId: 'techkids-ac7a7',\n    storageBucket: 'techkids-ac7a7.appspot.com',\n    messagingSenderId: '809846546437',\n  },\n  url: {\n    main: 'http://timmay.local:3000',\n    api: 'http://localhost:3000/api',\n    shop: 'http://shopDomain.timmay.local:3000',\n  },\n  cookies: {\n    domain: 'timmay.local',\n    maxAge: 60 * 60 * 1000,\n  },\n};\n","import { ProfileState } from '@client/store';\n\nexport const checkFollowStatus = (profileState: ProfileState, item: any) => {\n  return profileState && profileState.authUser && item && item.followBy.indexOf(profileState.authUser.id) !== -1 ? true : false;\n};\n","export const isMobile = (req: any) => {\n  const userAgent = req ? req.headers['user-agent'] : navigator.userAgent;\n  return (userAgent.match(/Android/i)\n    || userAgent.match(/webOS/i)\n    || userAgent.match(/iPhone/i)\n    || userAgent.match(/iPad/i)\n    || userAgent.match(/iPod/i)\n    || userAgent.match(/BlackBerry/i)\n    || userAgent.match(/Windows Phone/i)\n  ) ? true : false;\n};\n","import { AuthUser } from '@client/store';\n\nexport const checkPermission = (authUser: AuthUser, requiredPermission: string) => {\n  if (!requiredPermission) {\n    return true;\n  }\n\n  return requiredPermission && authUser && authUser.permissions && authUser.permissions.indexOf(requiredPermission) > -1;\n};\n","import { getServiceProxy } from '@client/services';\nimport { config } from '@client/config';\n\nexport const checkSubdomain = async (req: any, res: any, next: any) => {\n  if (req.subdomains && req.subdomains.length > 0) {\n    let shopDomain = '';\n    if (config.url.main === `https://timmay.vn` && req.subdomains[0] !== `www`) {\n      shopDomain = req.subdomains[0];\n    } else if (config.url.main === `https://test.timmay.vn` && req.subdomains[1] !== `www`) {\n      shopDomain = req.subdomains[1];\n    } else if (config.url.main.indexOf(`techkids.io`) > -1 && req.subdomains[1] !== `www`) {\n      shopDomain = req.subdomains[1];\n    } else if (req.subdomains[0] !== `www`) {\n      shopDomain = req.subdomains[0];\n    }\n\n    if (shopDomain) {\n      const authUserId = req.authUser ? req.authUser.id : '';\n      const serviceProxies = getServiceProxy();\n      const shopResult = await serviceProxies.findShopByDomain(shopDomain, authUserId);\n\n      if (shopResult) {\n        req.shopInfo = shopResult;\n        const allowPaths = ['/thong-tin-cua-hang', '/bai-dang-cua-hang'];\n        if (allowPaths.indexOf(req.url) > -1 || req.url.indexOf('/bai-dang-cua-hang') > -1) {\n          next();\n        } else {\n          res.redirect('/thong-tin-cua-hang');\n        }\n      } else {\n        // custom 404 page\n        res.redirect(`${config.url.main}/not-found`);\n      }\n    } else {\n      next();\n    }\n  } else {\n    next();\n  }\n};\n","import { config } from '@client/config';\n\nexport const clearCookie = async (_req: any, res: any) => {\n  res.clearCookie('token', {domain: config.cookies.domain}).redirect('/');\n};\n","// PENDING / PUBLIC / STOPPED / REJECTED / DELETED\nexport const newsStatus = {\n  PENDING: 'PENDING',\n  PUBLIC: 'PUBLIC',\n  STOPPED: 'STOPPED',\n  REJECTED: 'REJECTED',\n  DELETED: 'DELETED',\n};\n\nexport const newsTypeConst = {\n  SELL: 'SELL',\n  LEASE: 'LEASE',\n  BUY: 'BUY',\n  RENT: 'RENT',\n};\n\nexport const notificationState = {\n  READ: 'READ',\n  UNREAD: 'UNREAD',\n};\n\nexport const reportResults = {\n  SKIP: 'SKIP',\n  DELETE: 'DELETE',\n};\n\nexport const priceRanges = [\n  { min: 100000000, max: 500000000 },\n  { min: 500000000, max: 1000000000 },\n  { min: 1000000000, max: 5000000000 },\n  { min: 5000000000, max: 10000000000 },\n  { min: 10000000000, max: 50000000000 },\n];\n\nexport const newsStates = [\n  { value: 'NEW', label: 'Mới' },\n  { value: 'USED', label: 'Nhập bãi' },\n  { value: 'LIQUIDATE', label: 'Thanh lý' },\n];\n\nexport const newsTypes = [\n  { value: 'SELL', label: 'Cần bán' },\n  { value: 'LEASE', label: 'Cần cho thuê' },\n  { value: 'BUY', label: 'Cần mua' },\n  { value: 'RENT', label: 'Cần thuê' },\n];\n\nexport const storePackages = [\n  { label: '1 tháng', value: 86400 * 30 * 1000, price: 100000, imageUrl: '' },\n  { label: '3 tháng', value: 3 * 86400 * 30 * 1000, price: 300000, imageUrl: '/static/images/tag30k.png' },\n  { label: '6 tháng', value: 6 * 86400 * 30 * 1000, price: 600000, imageUrl: '/static/images/tag50k.png' },\n  { label: '12 tháng', value: 12 * 86400 * 30 * 1000, price: 1200000, imageUrl: '/static/images/tag990k.png' },\n];\n\nexport const paymentMethods = [\n  { label: 'Thẻ ngân hàng nội địa', value: 'domesticCard', imageUrl: ['/static/images/credit-card.png'] },\n  { label: 'Thẻ quốc tế', value: 'globalCard', imageUrl: ['/static/images/Visa.png', '/static/images/Mastercard.png'] },\n  { label: 'Ví momo', value: 'momoWallet', imageUrl: ['/static/images/momo.png'] },\n];\n\nexport const reportReasons = [\n  {label: 'Báo tin đã bán', value: 'SOLD'},\n  {label: 'Báo tin vi phạm', value: 'VIOLATE'},\n  {label: 'Báo tin đăng sai', value: 'WRONG_INFO'},\n];\n","export const convertVietnamese = (str: string) => {\n  let result = str.toLowerCase();\n  result = result.replace(/à|á|ạ|ả|ã|â|ầ|ấ|ậ|ẩ|ẫ|ă|ằ|ắ|ặ|ẳ|ẵ/gi, 'a');\n  result = result.replace(/è|é|ẹ|ẻ|ẽ|ê|ề|ế|ệ|ể|ễ/gi, 'e');\n  result = result.replace(/ì|í|ị|ỉ|ĩ/gi, 'i');\n  result = result.replace(/ò|ó|ọ|ỏ|õ|ô|ồ|ố|ộ|ổ|ỗ|ơ|ờ|ớ|ợ|ở|ỡ/gi, 'o');\n  result = result.replace(/ù|ú|ụ|ủ|ũ|ư|ừ|ứ|ự|ử|ữ/gi, 'u');\n  result = result.replace(/ỳ|ý|ỵ|ỷ|ỹ/gi, 'y');\n  result = result.replace(/đ/gi, 'd');\n  result = result.replace(/!|@|%|\\^|\\*|\\(|\\)|\\+|\\=|\\<|\\>|\\?|\\/|,|\\.|\\:|\\;|\\'|\\\"|\\&|\\#|\\[|\\]|~|\\$|_|`|-|{|}|\\||\\\\/gi, ' ');\n  result = result.replace(/ + /gi, ' ');\n  result = result.trim();\n  return result;\n};\n","import firebase from 'firebase/app';\nimport 'firebase/auth';\nimport { config } from '@client/config';\n\nexport const initializeFirebaseApp = () => {\n  if (!firebase.apps.length) {\n    firebase.initializeApp(config.firebase);\n  }\n  firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL)\n    // tslint:disable-next-line:no-console\n    .catch((error) => console.log(error));\n};\n","const formatter = new Intl.NumberFormat('de-DE', {\n  style: 'currency',\n  currency: 'VND',\n  currencyDisplay: 'code',\n  minimumFractionDigits: 0,\n});\n\nconst formatMoney = formatter.format;\n\nexport {\n  formatMoney,\n};\n","import { MetadataState } from '@client/store';\n\nexport const generateFilters = (query: any, metadataState: MetadataState) => {\n  const availableFilters: any = {};\n\n  if (query.keyword) {\n    availableFilters.keyword = query.keyword;\n  }\n  if (query.minPrice) {\n    availableFilters.minPrice = query.minPrice;\n  }\n  if (query.maxPrice) {\n    availableFilters.maxPrice = query.maxPrice;\n  }\n  if (query.minWeight) {\n    availableFilters.weightRange = metadataState.weightRanges.filter((item: any) => item.min === Number(query.minWeight))[0]._id;\n  }\n  if (query.state) {\n    availableFilters.state = query.state;\n  }\n  if (query.newsType) {\n    availableFilters.newsType = query.newsType;\n  }\n  if (query.category) {\n    availableFilters.category = metadataState.categories.filter((item: any) => item.slug === query.category)[0]._id;\n  }\n  if (query.brand) {\n    availableFilters.brand = metadataState.brands.filter((item: any) => item.slug === query.brand)[0]._id;\n  }\n  if (query.location) {\n    availableFilters.location = metadataState.provinces.filter((item: any) => item.slug === query.location)[0]._id;\n  }\n\n  return availableFilters;\n};\n","import { v4 } from 'uuid';\nimport { config } from '@client/config';\n\nconst recentViewedCookie = 'recent_viewed';\nexport const generateRecentViewedKey = (req: any, res: any, next: any) => {\n  if (!req.cookies[recentViewedCookie]) {\n    const recentViewedKey = v4();\n    res.cookie(recentViewedCookie, recentViewedKey, {domain: config.cookies.domain});\n  }\n  next();\n};\n","import { SearchFilters } from '@client/store';\n\nexport const generateSearchUrl = (filters: SearchFilters & {minWeight?: number; maxWeight?: number}) => {\n  const filterValues: any = {};\n\n  if (filters.keyword) {\n    filterValues.keyword = filters.keyword;\n  }\n  if (Number(filters.minPrice)) {\n    filterValues.minPrice = Number(filters.minPrice);\n  }\n  if (Number(filters.maxPrice)) {\n    filterValues.maxPrice = Number(filters.maxPrice);\n  }\n  if (Number(filters.minWeight)) {\n    filterValues.minWeight = Number(filters.minWeight);\n  }\n  if (Number(filters.maxWeight)) {\n    filterValues.maxWeight = Number(filters.maxWeight);\n  }\n  if (filters.state) {\n    filterValues.state = filters.state;\n  }\n  if (filters.newsType) {\n    filterValues.newsType = filters.newsType;\n  }\n  if (filters.category) {\n    filterValues.category = filters.category;\n  }\n  if (filters.brand) {\n    filterValues.brand = filters.brand;\n  }\n  if (filters.model) {\n    filterValues.model = filters.model;\n  }\n  if (filters.location) {\n    filterValues.location = filters.location;\n  }\n\n  return Object.keys(filterValues).sort().map((item) => `${item}=${filterValues[item]}`).join('&');\n};\n","export const getBase64Image = (img: any, callback: any) => {\n  const reader = new FileReader();\n  reader.addEventListener('load', () => callback(reader.result));\n  reader.readAsDataURL(img);\n};\n","export const getImageUrl = (imageUrl: string, imageType: 'large'|'small') => {\n  return imageUrl ? imageUrl.indexOf('.jpg') === -1 && imageUrl.indexOf('.png') === -1 ? `${imageUrl}-${imageType}.jpg` : imageUrl : '';\n};\n","import { appMenuConfigs, authMenuConfigs, statisticsMenuConfigs } from '@client/modules/admin/menuConfigs';\n\nexport const getMenuConfigs = () => {\n  return [\n    authMenuConfigs,\n    appMenuConfigs,\n    statisticsMenuConfigs,\n  ];\n};\n","import { config } from '@client/config';\n\nexport const getShopUrl = (shopDomain: string) => {\n  return config.url.shop.replace('shopDomain', shopDomain);\n};\n","export * from './firebase';\nexport * from './setCookie';\nexport * from './formatter';\nexport * from './submitLoginForm';\nexport * from './validateField';\nexport * from './clearCookie';\nexport * from './metadata';\nexport * from './getBase64Image';\nexport * from './getImageUrl';\nexport * from './constants';\nexport * from './checkSubdomain';\nexport * from './checkFollowStatus';\nexport * from './getShopUrl';\nexport * from './generateSearchUrl';\nexport * from './generateFilters';\nexport * from './generateRecentViewedKey';\nexport * from './checkIsMobile';\nexport * from './convertVietnamese';\nexport * from './getMenuConfigs';\nexport * from './checkPermission';\n","export const metadata = {\n\n};\n","import { config } from '@client/config';\n\nexport const setCookie = async (req: any, res: any) => {\n  const token = req.body.token;\n  res.cookie('token', `Bearer ${token}`, {domain: config.cookies.domain}).redirect('/');\n};\n","export const submitLoginForm = (idToken: string) => {\n  const form = document.getElementById('form');\n  const input = document.createElement('input');\n  input.type = 'text';\n  input.name = 'token';\n  input.value = idToken;\n  form!.appendChild(input);\n  (form as any).submit();\n};\n","import { FormikContext } from 'formik';\nimport * as yup from 'yup';\n\ninterface ValidateFieldInput {\n  fieldName: string;\n  context: FormikContext<any>;\n  validateSchema: yup.Schema<any>;\n}\n\nexport const validateField = (params: ValidateFieldInput) => {\n  try {\n    params.validateSchema.validateSyncAt(params.fieldName, params.context.values);\n    params.context.setFieldError(params.fieldName, '');\n  } catch (error) {\n    params.context.setFieldError(params.fieldName, error.message);\n  }\n};\n","export const appMenuConfigs = {\n  name: 'appManagement',\n  icon: 'qrcode',\n  items: [\n    {\n      name: 'reportsManagement',\n      path: '/quan-ly/bao-cao-vi-pham',\n      permission: '',\n      children: [],\n    },\n    {\n      name: 'brandsManagement',\n      path: '/quan-ly/danh-sach-hang',\n      permission: '',\n      children: [],\n    },\n    {\n      name: 'categoriesManagement',\n      path: '/quan-ly/chung-loai-may',\n      permission: '',\n      children: [],\n    },\n    {\n      name: 'modelsManagement',\n      path: '/quan-ly/danh-sach-models',\n      permission: '',\n      children: [],\n    },\n    {\n      name: 'weightRangesManagement',\n      path: '/quan-ly/khoang-trong-luong',\n      permission: '',\n      children: [],\n    },\n    {\n      name: 'rentalPeriodsManagement',\n      path: '/quan-ly/thoi-gian-thue',\n      permission: '',\n      children: [],\n    },\n    {\n      name: 'featureBrandsManagement',\n      path: '/quan-ly/hang-hop-tac',\n      permission: '',\n      children: [],\n    },\n    {\n      name: 'adsenseManagement',\n      path: '/quan-ly/quang-cao',\n      permission: '',\n      children: [],\n    },\n    {\n      name: 'uploadExcelFile',\n      path: '/quan-ly/dang-tin',\n      permission: '',\n      children: [],\n    },\n  ],\n};\n\nexport const authMenuConfigs = {\n  name: 'authManagement',\n  icon: 'user',\n  items: [\n    {\n      name: 'usersManagement',\n      path: '/quan-ly/nguoi-dung',\n      permission: '',\n      children: [],\n    },\n  ],\n};\n\nexport const statisticsMenuConfigs = {\n  name: 'statisticsManagement',\n  icon: 'rise',\n  items: [\n    {\n      name: 'newsStatistics',\n      path: '/quan-ly/thong-ke-tin-bai',\n      permission: '',\n      children: [],\n    },\n  ],\n};\n","import React from 'react';\nimport firebase from 'firebase/app';\nimport 'firebase/auth';\nimport { initializeFirebaseApp, submitLoginForm } from '../core';\n\ninterface Props {}\ninterface State {}\nclass RefreshTokenIframe extends React.Component<Props, State> {\n  refreshTokenInterval: any;\n\n  componentDidMount () {\n    initializeFirebaseApp();\n    firebase.auth().onAuthStateChanged((user) => {\n      if (user) {\n        this.refreshTokenInterval = setInterval(() => {\n          firebase.auth().currentUser!.getIdToken(true).then((idToken) => {\n            submitLoginForm(idToken);\n          });\n        }, 30 * 60 * 1000);\n      }\n    });\n  }\n\n  componentWillUnmount () {\n    clearInterval(this.refreshTokenInterval);\n  }\n\n  render () {\n    return (\n      <div>\n        <form id='form' method='post' action='/auth/login' style={{display: 'none'}} />\n      </div>\n    );\n  }\n}\n\nexport default RefreshTokenIframe;\n","import 'firebase/auth';\nimport { ServiceProxy } from './service-proxies';\nimport { config } from '@client/config';\nimport fetch from 'isomorphic-fetch';\n\nconst getAuthHttp = (idToken: string) => {\n  return {\n    fetch: (url: any, option: any): Promise<Response> => {\n      option.headers.Authorization = `${idToken}`;\n      option.headers['Access-Control-Allow-Origin'] = '*';\n      option.credentials = 'include';\n      return fetch(url, option);\n    },\n  };\n};\n\nconst getServiceProxy = (idToken = ''): ServiceProxy => {\n  const httpOption = getAuthHttp(idToken);\n  return new ServiceProxy(\n    config.url.api,\n    httpOption,\n  );\n};\n\nexport {\n  getServiceProxy,\n};\n","/* tslint:disable */\n//----------------------\n// <auto-generated>\n//     Generated using the NSwag toolchain v12.0.5.0 (NJsonSchema v9.13.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)\n// </auto-generated>\n//----------------------\n// ReSharper disable InconsistentNaming\n\nexport class ServiceProxy {\n    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };\n    private baseUrl: string;\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\n\n    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {\n        this.http = http ? http : <any>window;\n        this.baseUrl = baseUrl ? baseUrl : \"http://localhost:3000/api\";\n    }\n\n    /**\n     * Register user\n     * @param body (optional) \n     * @return successful operation\n     */\n    registerUser(body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/auth\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processRegisterUser(_response);\n        });\n    }\n\n    protected processRegisterUser(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Find permissions list of all modules\n     * @return successful operation\n     */\n    findPermissions(): Promise<any> {\n        let url_ = this.baseUrl + \"/permissions\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindPermissions(_response);\n        });\n    }\n\n    protected processFindPermissions(response: Response): Promise<any> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<any>(<any>null);\n    }\n\n    /**\n     * Check role name exist\n     * @param roleName roleName\n     * @return successful operation\n     */\n    checkRoleNameExist(roleName: string): Promise<CheckRoleNameExistResult> {\n        let url_ = this.baseUrl + \"/roles/customs/check-name-exist/{roleName}\";\n        if (roleName === undefined || roleName === null)\n            throw new Error(\"The parameter 'roleName' must be defined.\");\n        url_ = url_.replace(\"{roleName}\", encodeURIComponent(\"\" + roleName)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCheckRoleNameExist(_response);\n        });\n    }\n\n    protected processCheckRoleNameExist(response: Response): Promise<CheckRoleNameExistResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <CheckRoleNameExistResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<CheckRoleNameExistResult>(<any>null);\n    }\n\n    /**\n     * Find all roles\n     * @return successful operation\n     */\n    getAllRoles(): Promise<GetAllRolesResult> {\n        let url_ = this.baseUrl + \"/roles/customs/get-all\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processGetAllRoles(_response);\n        });\n    }\n\n    protected processGetAllRoles(response: Response): Promise<GetAllRolesResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <GetAllRolesResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<GetAllRolesResult>(<any>null);\n    }\n\n    /**\n     * Find role by id\n     * @param roleId roleId\n     * @return successful operation\n     */\n    findRoleById(roleId: string): Promise<Role> {\n        let url_ = this.baseUrl + \"/roles/{roleId}\";\n        if (roleId === undefined || roleId === null)\n            throw new Error(\"The parameter 'roleId' must be defined.\");\n        url_ = url_.replace(\"{roleId}\", encodeURIComponent(\"\" + roleId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindRoleById(_response);\n        });\n    }\n\n    protected processFindRoleById(response: Response): Promise<Role> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Role>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Role>(<any>null);\n    }\n\n    /**\n     * Update role\n     * @param roleId roleId\n     * @param body (optional) \n     * @return successful operation\n     */\n    updateRole(roleId: string, body: any | undefined): Promise<Role> {\n        let url_ = this.baseUrl + \"/roles/{roleId}\";\n        if (roleId === undefined || roleId === null)\n            throw new Error(\"The parameter 'roleId' must be defined.\");\n        url_ = url_.replace(\"{roleId}\", encodeURIComponent(\"\" + roleId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processUpdateRole(_response);\n        });\n    }\n\n    protected processUpdateRole(response: Response): Promise<Role> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Role>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Role>(<any>null);\n    }\n\n    /**\n     * Find roles\n     * @param search (optional) search\n     * @param permissions (optional) filter by permissions\n     * @param first number of records returned\n     * @param sortBy sort field\n     * @param before (optional) before token\n     * @param after (optional) after token\n     * @return successful operation\n     */\n    findRoles(search: string | undefined, permissions: string[] | undefined, first: string, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindRolesResult> {\n        let url_ = this.baseUrl + \"/roles?\";\n        if (search === null)\n            throw new Error(\"The parameter 'search' cannot be null.\");\n        else if (search !== undefined)\n            url_ += \"search=\" + encodeURIComponent(\"\" + search) + \"&\"; \n        if (permissions === null)\n            throw new Error(\"The parameter 'permissions' cannot be null.\");\n        else if (permissions !== undefined)\n            permissions && permissions.forEach(item => { url_ += \"permissions=\" + encodeURIComponent(\"\" + item) + \"&\"; });\n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindRoles(_response);\n        });\n    }\n\n    protected processFindRoles(response: Response): Promise<FindRolesResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FindRolesResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FindRolesResult>(<any>null);\n    }\n\n    /**\n     * Create role\n     * @param body (optional) \n     * @return successful operation\n     */\n    createRole(body: any | undefined): Promise<Role> {\n        let url_ = this.baseUrl + \"/roles\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCreateRole(_response);\n        });\n    }\n\n    protected processCreateRole(response: Response): Promise<Role> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Role>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Role>(<any>null);\n    }\n\n    /**\n     * Find profile\n     * @return successful operation\n     */\n    findProfile(): Promise<User> {\n        let url_ = this.baseUrl + \"/profiles\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindProfile(_response);\n        });\n    }\n\n    protected processFindProfile(response: Response): Promise<User> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<User>(<any>null);\n    }\n\n    /**\n     * Find use profile for guess view\n     * @param userId userId\n     * @return successful operation\n     */\n    findPublicProfile(userId: string): Promise<User> {\n        let url_ = this.baseUrl + \"/profiles/{userId}\";\n        if (userId === undefined || userId === null)\n            throw new Error(\"The parameter 'userId' must be defined.\");\n        url_ = url_.replace(\"{userId}\", encodeURIComponent(\"\" + userId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindPublicProfile(_response);\n        });\n    }\n\n    protected processFindPublicProfile(response: Response): Promise<User> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<User>(<any>null);\n    }\n\n    /**\n     * Update profile\n     * @param userId userId\n     * @param body (optional) \n     * @return successful operation\n     */\n    updateProfile(userId: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/profiles/{userId}\";\n        if (userId === undefined || userId === null)\n            throw new Error(\"The parameter 'userId' must be defined.\");\n        url_ = url_.replace(\"{userId}\", encodeURIComponent(\"\" + userId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processUpdateProfile(_response);\n        });\n    }\n\n    protected processUpdateProfile(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Find users\n     * @param search (optional) search\n     * @param roles (optional) filter by roles\n     * @param first number of records returned\n     * @param sortBy sort field\n     * @param before (optional) before token\n     * @param after (optional) after token\n     * @return successful operation\n     */\n    findUsers(search: string | undefined, roles: string[] | undefined, first: number, sortBy: string, before: number | undefined, after: number | undefined): Promise<FindUserResult> {\n        let url_ = this.baseUrl + \"/users?\";\n        if (search === null)\n            throw new Error(\"The parameter 'search' cannot be null.\");\n        else if (search !== undefined)\n            url_ += \"search=\" + encodeURIComponent(\"\" + search) + \"&\"; \n        if (roles === null)\n            throw new Error(\"The parameter 'roles' cannot be null.\");\n        else if (roles !== undefined)\n            roles && roles.forEach(item => { url_ += \"roles=\" + encodeURIComponent(\"\" + item) + \"&\"; });\n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindUsers(_response);\n        });\n    }\n\n    protected processFindUsers(response: Response): Promise<FindUserResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FindUserResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FindUserResult>(<any>null);\n    }\n\n    /**\n     * Create user\n     * @param body (optional) \n     * @return successful operation\n     */\n    createUser(body: any | undefined): Promise<User> {\n        let url_ = this.baseUrl + \"/users\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCreateUser(_response);\n        });\n    }\n\n    protected processCreateUser(response: Response): Promise<User> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            let result201: any = null;\n            result201 = _responseText === \"\" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);\n            return result201;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<User>(<any>null);\n    }\n\n    /**\n     * Check phone number exist\n     * @param phoneNo phoneNo\n     * @return successful operation\n     */\n    checkPhoneNoExist(phoneNo: string): Promise<CheckPhoneNoExistResult> {\n        let url_ = this.baseUrl + \"/users/customs/check-phone-number-exist/{phoneNo}\";\n        if (phoneNo === undefined || phoneNo === null)\n            throw new Error(\"The parameter 'phoneNo' must be defined.\");\n        url_ = url_.replace(\"{phoneNo}\", encodeURIComponent(\"\" + phoneNo)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCheckPhoneNoExist(_response);\n        });\n    }\n\n    protected processCheckPhoneNoExist(response: Response): Promise<CheckPhoneNoExistResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <CheckPhoneNoExistResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<CheckPhoneNoExistResult>(<any>null);\n    }\n\n    /**\n     * Check email exist\n     * @param email email\n     * @return successful operation\n     */\n    checkEmailExist(email: string): Promise<CheckEmailExistResult> {\n        let url_ = this.baseUrl + \"/users/customs/check-email-exist/{email}\";\n        if (email === undefined || email === null)\n            throw new Error(\"The parameter 'email' must be defined.\");\n        url_ = url_.replace(\"{email}\", encodeURIComponent(\"\" + email)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCheckEmailExist(_response);\n        });\n    }\n\n    protected processCheckEmailExist(response: Response): Promise<CheckEmailExistResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <CheckEmailExistResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<CheckEmailExistResult>(<any>null);\n    }\n\n    /**\n     * Find user by id\n     * @param userId userId\n     * @return successful operation\n     */\n    findUserById(userId: string): Promise<User> {\n        let url_ = this.baseUrl + \"/users/{userId}\";\n        if (userId === undefined || userId === null)\n            throw new Error(\"The parameter 'userId' must be defined.\");\n        url_ = url_.replace(\"{userId}\", encodeURIComponent(\"\" + userId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindUserById(_response);\n        });\n    }\n\n    protected processFindUserById(response: Response): Promise<User> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<User>(<any>null);\n    }\n\n    /**\n     * Update user\n     * @param userId userId\n     * @param body (optional) \n     * @return successful operation\n     */\n    updateUser(userId: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/users/{userId}\";\n        if (userId === undefined || userId === null)\n            throw new Error(\"The parameter 'userId' must be defined.\");\n        url_ = url_.replace(\"{userId}\", encodeURIComponent(\"\" + userId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processUpdateUser(_response);\n        });\n    }\n\n    protected processUpdateUser(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * update adsense\n     * @param adsenseId adsenseId\n     * @param body (optional) \n     * @return successful operation\n     */\n    updateAdsense(adsenseId: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/adsense/{adsenseId}\";\n        if (adsenseId === undefined || adsenseId === null)\n            throw new Error(\"The parameter 'adsenseId' must be defined.\");\n        url_ = url_.replace(\"{adsenseId}\", encodeURIComponent(\"\" + adsenseId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processUpdateAdsense(_response);\n        });\n    }\n\n    protected processUpdateAdsense(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Create adsense\n     * @param body (optional) \n     * @return successful operation\n     */\n    createAdsense(body: any | undefined): Promise<Adsense> {\n        let url_ = this.baseUrl + \"/adsense\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCreateAdsense(_response);\n        });\n    }\n\n    protected processCreateAdsense(response: Response): Promise<Adsense> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Adsense>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            let result201: any = null;\n            result201 = _responseText === \"\" ? null : <Adsense>JSON.parse(_responseText, this.jsonParseReviver);\n            return result201;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Adsense>(<any>null);\n    }\n\n    /**\n     * Get adsense\n     * @param first limit size\n     * @param sortBy order by\n     * @param before (optional) before\n     * @param after (optional) after\n     * @return successful operation\n     */\n    getAdsense(first: number, sortBy: string, before: any | undefined, after: any | undefined): Promise<GetAdsenseResult> {\n        let url_ = this.baseUrl + \"/adsense?\";\n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processGetAdsense(_response);\n        });\n    }\n\n    protected processGetAdsense(response: Response): Promise<GetAdsenseResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <GetAdsenseResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<GetAdsenseResult>(<any>null);\n    }\n\n    /**\n     * update feature brand\n     * @param featureBrandId featureBrandId\n     * @param body (optional) \n     * @return successful operation\n     */\n    updateFeatureBrand(featureBrandId: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/feature-brands/{featureBrandId}\";\n        if (featureBrandId === undefined || featureBrandId === null)\n            throw new Error(\"The parameter 'featureBrandId' must be defined.\");\n        url_ = url_.replace(\"{featureBrandId}\", encodeURIComponent(\"\" + featureBrandId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processUpdateFeatureBrand(_response);\n        });\n    }\n\n    protected processUpdateFeatureBrand(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Get feature brands\n     * @param first limit size\n     * @param sortBy order by\n     * @param before (optional) before\n     * @param after (optional) after\n     * @return successful operation\n     */\n    getFeatureBrands(first: number, sortBy: string, before: any | undefined, after: any | undefined): Promise<GetFeatureBrandsResult> {\n        let url_ = this.baseUrl + \"/feature-brands?\";\n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processGetFeatureBrands(_response);\n        });\n    }\n\n    protected processGetFeatureBrands(response: Response): Promise<GetFeatureBrandsResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <GetFeatureBrandsResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<GetFeatureBrandsResult>(<any>null);\n    }\n\n    /**\n     * Create feature brand for ads\n     * @param body (optional) \n     * @return successful operation\n     */\n    createFeatureBrand(body: any | undefined): Promise<FeatureBrand> {\n        let url_ = this.baseUrl + \"/feature-brands\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCreateFeatureBrand(_response);\n        });\n    }\n\n    protected processCreateFeatureBrand(response: Response): Promise<FeatureBrand> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FeatureBrand>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            let result201: any = null;\n            result201 = _responseText === \"\" ? null : <FeatureBrand>JSON.parse(_responseText, this.jsonParseReviver);\n            return result201;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FeatureBrand>(<any>null);\n    }\n\n    /**\n     * Update rental period\n     * @param rentalPeriodId rental period id\n     * @param body (optional) \n     * @return successful operation\n     */\n    updateRentalPeriod(rentalPeriodId: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/rental-periods/{rentalPeriodId}\";\n        if (rentalPeriodId === undefined || rentalPeriodId === null)\n            throw new Error(\"The parameter 'rentalPeriodId' must be defined.\");\n        url_ = url_.replace(\"{rentalPeriodId}\", encodeURIComponent(\"\" + rentalPeriodId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processUpdateRentalPeriod(_response);\n        });\n    }\n\n    protected processUpdateRentalPeriod(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Create rental period item\n     * @param body (optional) \n     * @return successful operation\n     */\n    createRentalPeriod(body: any | undefined): Promise<RentalPeriod> {\n        let url_ = this.baseUrl + \"/rental-periods\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCreateRentalPeriod(_response);\n        });\n    }\n\n    protected processCreateRentalPeriod(response: Response): Promise<RentalPeriod> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <RentalPeriod>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            let result201: any = null;\n            result201 = _responseText === \"\" ? null : <RentalPeriod>JSON.parse(_responseText, this.jsonParseReviver);\n            return result201;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<RentalPeriod>(<any>null);\n    }\n\n    /**\n     * Get rental periods\n     * @return successful operation\n     */\n    getAllRentalPeriods(): Promise<GetAllRentalPeriodsResult> {\n        let url_ = this.baseUrl + \"/rental-periods/customs/get-all\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processGetAllRentalPeriods(_response);\n        });\n    }\n\n    protected processGetAllRentalPeriods(response: Response): Promise<GetAllRentalPeriodsResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <GetAllRentalPeriodsResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<GetAllRentalPeriodsResult>(<any>null);\n    }\n\n    /**\n     * Update weight range\n     * @param weightRangeId weight range Id\n     * @param body (optional) \n     * @return successful operation\n     */\n    updateWeightRange(weightRangeId: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/weight-ranges/{weightRangeId}\";\n        if (weightRangeId === undefined || weightRangeId === null)\n            throw new Error(\"The parameter 'weightRangeId' must be defined.\");\n        url_ = url_.replace(\"{weightRangeId}\", encodeURIComponent(\"\" + weightRangeId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processUpdateWeightRange(_response);\n        });\n    }\n\n    protected processUpdateWeightRange(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Create weight range item\n     * @param body (optional) \n     * @return successful operation\n     */\n    createWeightRange(body: any | undefined): Promise<WeightRange> {\n        let url_ = this.baseUrl + \"/weight-ranges\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCreateWeightRange(_response);\n        });\n    }\n\n    protected processCreateWeightRange(response: Response): Promise<WeightRange> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <WeightRange>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            let result201: any = null;\n            result201 = _responseText === \"\" ? null : <WeightRange>JSON.parse(_responseText, this.jsonParseReviver);\n            return result201;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<WeightRange>(<any>null);\n    }\n\n    /**\n     * Get weight ranges\n     * @return successful operation\n     */\n    getAllWeightRanges(): Promise<GetAllWeightRangesResult> {\n        let url_ = this.baseUrl + \"/weight-ranges/customs/get-all\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processGetAllWeightRanges(_response);\n        });\n    }\n\n    protected processGetAllWeightRanges(response: Response): Promise<GetAllWeightRangesResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <GetAllWeightRangesResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<GetAllWeightRangesResult>(<any>null);\n    }\n\n    /**\n     * Get common search keywords\n     * @param first limit size\n     * @param sortBy order by\n     * @param before (optional) before\n     * @param after (optional) after\n     * @return successful operation\n     */\n    getCommonKeywords(first: number, sortBy: string, before: any | undefined, after: any | undefined): Promise<GetCommonKeywordsResult> {\n        let url_ = this.baseUrl + \"/common-keywords?\";\n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processGetCommonKeywords(_response);\n        });\n    }\n\n    protected processGetCommonKeywords(response: Response): Promise<GetCommonKeywordsResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <GetCommonKeywordsResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<GetCommonKeywordsResult>(<any>null);\n    }\n\n    /**\n     * Create recent viewed item\n     * @param body (optional) \n     * @return successful operation\n     */\n    createRecentViewed(body: any | undefined): Promise<RecentViewedItem> {\n        let url_ = this.baseUrl + \"/recent-viewed\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCreateRecentViewed(_response);\n        });\n    }\n\n    protected processCreateRecentViewed(response: Response): Promise<RecentViewedItem> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <RecentViewedItem>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            let result201: any = null;\n            result201 = _responseText === \"\" ? null : <RecentViewedItem>JSON.parse(_responseText, this.jsonParseReviver);\n            return result201;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<RecentViewedItem>(<any>null);\n    }\n\n    /**\n     * Get recent viewed items by users or uuid key\n     * @param first limit size\n     * @param sortBy order by\n     * @param before (optional) before\n     * @param after (optional) after\n     * @return successful operation\n     */\n    getRecentViewed(first: number, sortBy: string, before: any | undefined, after: any | undefined): Promise<GetRecentViewedResult> {\n        let url_ = this.baseUrl + \"/recent-viewed?\";\n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processGetRecentViewed(_response);\n        });\n    }\n\n    protected processGetRecentViewed(response: Response): Promise<GetRecentViewedResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <GetRecentViewedResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<GetRecentViewedResult>(<any>null);\n    }\n\n    /**\n     * Search news most follow\n     * @param shopId (optional) shop Id\n     * @param first limit size\n     * @param sortBy order by\n     * @param otherSortBy other order by\n     * @param before (optional) before\n     * @param after (optional) after\n     * @return successful operation\n     */\n    searchNewsMostFollow(shopId: number | undefined, first: number, sortBy: string, otherSortBy: string, before: any | undefined, after: any | undefined): Promise<SearchNewsMostFollowResult> {\n        let url_ = this.baseUrl + \"/search-news-most-follow?\";\n        if (shopId === null)\n            throw new Error(\"The parameter 'shopId' cannot be null.\");\n        else if (shopId !== undefined)\n            url_ += \"shopId=\" + encodeURIComponent(\"\" + shopId) + \"&\"; \n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (otherSortBy === undefined || otherSortBy === null)\n            throw new Error(\"The parameter 'otherSortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"otherSortBy=\" + encodeURIComponent(\"\" + otherSortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processSearchNewsMostFollow(_response);\n        });\n    }\n\n    protected processSearchNewsMostFollow(response: Response): Promise<SearchNewsMostFollowResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <SearchNewsMostFollowResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<SearchNewsMostFollowResult>(<any>null);\n    }\n\n    /**\n     * Count unread notification\n     * @param ownerId owner id\n     * @return successful operation\n     */\n    countUnreadNotifications(ownerId: string): Promise<CountUnreadNotificationsResult> {\n        let url_ = this.baseUrl + \"/notifications/{ownerId}\";\n        if (ownerId === undefined || ownerId === null)\n            throw new Error(\"The parameter 'ownerId' must be defined.\");\n        url_ = url_.replace(\"{ownerId}\", encodeURIComponent(\"\" + ownerId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCountUnreadNotifications(_response);\n        });\n    }\n\n    protected processCountUnreadNotifications(response: Response): Promise<CountUnreadNotificationsResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <CountUnreadNotificationsResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<CountUnreadNotificationsResult>(<any>null);\n    }\n\n    /**\n     * Read notifications\n     * @param ownerId owner id\n     * @param body (optional) \n     * @return successful operation\n     */\n    readNotifications(ownerId: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/notifications/{ownerId}\";\n        if (ownerId === undefined || ownerId === null)\n            throw new Error(\"The parameter 'ownerId' must be defined.\");\n        url_ = url_.replace(\"{ownerId}\", encodeURIComponent(\"\" + ownerId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processReadNotifications(_response);\n        });\n    }\n\n    protected processReadNotifications(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Find notifications\n     * @param first number of records returned\n     * @param sortBy sort field\n     * @param before (optional) before token\n     * @param after (optional) after token\n     * @return successful operation\n     */\n    findNotifications(first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindNotificationsResult> {\n        let url_ = this.baseUrl + \"/notifications?\";\n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindNotifications(_response);\n        });\n    }\n\n    protected processFindNotifications(response: Response): Promise<FindNotificationsResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FindNotificationsResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FindNotificationsResult>(<any>null);\n    }\n\n    /**\n     * Update report\n     * @param reportId report id\n     * @param body (optional) \n     * @return successful operation\n     */\n    updateReport(reportId: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/reports/{reportId}\";\n        if (reportId === undefined || reportId === null)\n            throw new Error(\"The parameter 'reportId' must be defined.\");\n        url_ = url_.replace(\"{reportId}\", encodeURIComponent(\"\" + reportId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processUpdateReport(_response);\n        });\n    }\n\n    protected processUpdateReport(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Find report by id\n     * @param reportId report id\n     * @return successful operation\n     */\n    findReportById(reportId: string): Promise<Report> {\n        let url_ = this.baseUrl + \"/reports/{reportId}\";\n        if (reportId === undefined || reportId === null)\n            throw new Error(\"The parameter 'reportId' must be defined.\");\n        url_ = url_.replace(\"{reportId}\", encodeURIComponent(\"\" + reportId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindReportById(_response);\n        });\n    }\n\n    protected processFindReportById(response: Response): Promise<Report> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Report>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Report>(<any>null);\n    }\n\n    /**\n     * Create report\n     * @param body (optional) \n     * @return successful operation\n     */\n    createReport(body: any | undefined): Promise<Report> {\n        let url_ = this.baseUrl + \"/reports\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCreateReport(_response);\n        });\n    }\n\n    protected processCreateReport(response: Response): Promise<Report> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Report>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            let result201: any = null;\n            result201 = _responseText === \"\" ? null : <Report>JSON.parse(_responseText, this.jsonParseReviver);\n            return result201;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Report>(<any>null);\n    }\n\n    /**\n     * Find reports\n     * @param search (optional) state filter\n     * @param state (optional) state filter\n     * @param reason (optional) reason filter\n     * @param first number of records returned\n     * @param sortBy sort field\n     * @param before (optional) before token\n     * @param after (optional) after token\n     * @return successful operation\n     */\n    findReports(search: string | undefined, state: State | undefined, reason: Reason | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindReportsResult> {\n        let url_ = this.baseUrl + \"/reports?\";\n        if (search === null)\n            throw new Error(\"The parameter 'search' cannot be null.\");\n        else if (search !== undefined)\n            url_ += \"search=\" + encodeURIComponent(\"\" + search) + \"&\"; \n        if (state === null)\n            throw new Error(\"The parameter 'state' cannot be null.\");\n        else if (state !== undefined)\n            url_ += \"state=\" + encodeURIComponent(\"\" + state) + \"&\"; \n        if (reason === null)\n            throw new Error(\"The parameter 'reason' cannot be null.\");\n        else if (reason !== undefined)\n            url_ += \"reason=\" + encodeURIComponent(\"\" + reason) + \"&\"; \n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindReports(_response);\n        });\n    }\n\n    protected processFindReports(response: Response): Promise<FindReportsResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FindReportsResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FindReportsResult>(<any>null);\n    }\n\n    /**\n     * Find shop by owner id\n     * @param ownerId shop owner id\n     * @return successful operation\n     */\n    findShopByOwner(ownerId: string): Promise<Shop> {\n        let url_ = this.baseUrl + \"/shop/get-by-owner/{ownerId}\";\n        if (ownerId === undefined || ownerId === null)\n            throw new Error(\"The parameter 'ownerId' must be defined.\");\n        url_ = url_.replace(\"{ownerId}\", encodeURIComponent(\"\" + ownerId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindShopByOwner(_response);\n        });\n    }\n\n    protected processFindShopByOwner(response: Response): Promise<Shop> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Shop>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Shop>(<any>null);\n    }\n\n    /**\n     * Find shop by id\n     * @param shopDomain shop domain\n     * @param authId (optional) authUserId\n     * @return successful operation\n     */\n    findShopByDomain(shopDomain: string, authId: string | undefined): Promise<Shop> {\n        let url_ = this.baseUrl + \"/shop/get-by-domain/{shopDomain}?\";\n        if (shopDomain === undefined || shopDomain === null)\n            throw new Error(\"The parameter 'shopDomain' must be defined.\");\n        url_ = url_.replace(\"{shopDomain}\", encodeURIComponent(\"\" + shopDomain)); \n        if (authId === null)\n            throw new Error(\"The parameter 'authId' cannot be null.\");\n        else if (authId !== undefined)\n            url_ += \"authId=\" + encodeURIComponent(\"\" + authId) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindShopByDomain(_response);\n        });\n    }\n\n    protected processFindShopByDomain(response: Response): Promise<Shop> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Shop>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Shop>(<any>null);\n    }\n\n    /**\n     * Find news by id\n     * @param shopId shop id\n     * @return successful operation\n     */\n    findShopById(shopId: string): Promise<Shop> {\n        let url_ = this.baseUrl + \"/shop/{shopId}\";\n        if (shopId === undefined || shopId === null)\n            throw new Error(\"The parameter 'shopId' must be defined.\");\n        url_ = url_.replace(\"{shopId}\", encodeURIComponent(\"\" + shopId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindShopById(_response);\n        });\n    }\n\n    protected processFindShopById(response: Response): Promise<Shop> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Shop>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Shop>(<any>null);\n    }\n\n    /**\n     * Update shop\n     * @param shopId shop id\n     * @param body (optional) \n     * @return successful operation\n     */\n    updateShop(shopId: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/shop/{shopId}\";\n        if (shopId === undefined || shopId === null)\n            throw new Error(\"The parameter 'shopId' must be defined.\");\n        url_ = url_.replace(\"{shopId}\", encodeURIComponent(\"\" + shopId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processUpdateShop(_response);\n        });\n    }\n\n    protected processUpdateShop(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Create shops\n     * @param body (optional) \n     * @return successful operation\n     */\n    createShop(body: any | undefined): Promise<Shop> {\n        let url_ = this.baseUrl + \"/shop\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCreateShop(_response);\n        });\n    }\n\n    protected processCreateShop(response: Response): Promise<Shop> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Shop>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            let result201: any = null;\n            result201 = _responseText === \"\" ? null : <Shop>JSON.parse(_responseText, this.jsonParseReviver);\n            return result201;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Shop>(<any>null);\n    }\n\n    /**\n     * Find shops\n     * @param search (optional) search query\n     * @param isActive (optional) isActive filter\n     * @param owner (optional) owner filter\n     * @param first number of records returned\n     * @param sortBy sort field\n     * @param before (optional) before token\n     * @param after (optional) after token\n     * @return successful operation\n     */\n    findShops(search: string | undefined, isActive: boolean | undefined, owner: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindShopsResult> {\n        let url_ = this.baseUrl + \"/shop?\";\n        if (search === null)\n            throw new Error(\"The parameter 'search' cannot be null.\");\n        else if (search !== undefined)\n            url_ += \"search=\" + encodeURIComponent(\"\" + search) + \"&\"; \n        if (isActive === null)\n            throw new Error(\"The parameter 'isActive' cannot be null.\");\n        else if (isActive !== undefined)\n            url_ += \"isActive=\" + encodeURIComponent(\"\" + isActive) + \"&\"; \n        if (owner === null)\n            throw new Error(\"The parameter 'owner' cannot be null.\");\n        else if (owner !== undefined)\n            url_ += \"owner=\" + encodeURIComponent(\"\" + owner) + \"&\"; \n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindShops(_response);\n        });\n    }\n\n    protected processFindShops(response: Response): Promise<FindShopsResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FindShopsResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FindShopsResult>(<any>null);\n    }\n\n    /**\n     * Find news by id\n     * @param newsId newsId\n     * @return successful operation\n     */\n    findNewsById(newsId: string): Promise<FindNewsDetail> {\n        let url_ = this.baseUrl + \"/news/{newsId}\";\n        if (newsId === undefined || newsId === null)\n            throw new Error(\"The parameter 'newsId' must be defined.\");\n        url_ = url_.replace(\"{newsId}\", encodeURIComponent(\"\" + newsId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindNewsById(_response);\n        });\n    }\n\n    protected processFindNewsById(response: Response): Promise<FindNewsDetail> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FindNewsDetail>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FindNewsDetail>(<any>null);\n    }\n\n    /**\n     * Update news\n     * @param newsId newsId\n     * @param body (optional) \n     * @return successful operation\n     */\n    updateNews(newsId: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/news/{newsId}\";\n        if (newsId === undefined || newsId === null)\n            throw new Error(\"The parameter 'newsId' must be defined.\");\n        url_ = url_.replace(\"{newsId}\", encodeURIComponent(\"\" + newsId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processUpdateNews(_response);\n        });\n    }\n\n    protected processUpdateNews(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Find news statistics for admin\n     * @param startDate startDate\n     * @param endDate endDate\n     * @return successful operation\n     */\n    findNewsStatisticsInfo(startDate: string, endDate: string): Promise<NewsStatisticsResult> {\n        let url_ = this.baseUrl + \"/news/statistics/info?\";\n        if (startDate === undefined || startDate === null)\n            throw new Error(\"The parameter 'startDate' must be defined and cannot be null.\");\n        else\n            url_ += \"startDate=\" + encodeURIComponent(\"\" + startDate) + \"&\"; \n        if (endDate === undefined || endDate === null)\n            throw new Error(\"The parameter 'endDate' must be defined and cannot be null.\");\n        else\n            url_ += \"endDate=\" + encodeURIComponent(\"\" + endDate) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindNewsStatisticsInfo(_response);\n        });\n    }\n\n    protected processFindNewsStatisticsInfo(response: Response): Promise<NewsStatisticsResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <NewsStatisticsResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<NewsStatisticsResult>(<any>null);\n    }\n\n    /**\n     * Find news by owner\n     * @param ownerId ownerId\n     * @param status news status\n     * @param first number of records returned\n     * @param sortBy sort field\n     * @param before (optional) before token\n     * @param after (optional) after token\n     * @return successful operation\n     */\n    findNewsByOwner(ownerId: string, status: string, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindNewsResultWithFollow> {\n        let url_ = this.baseUrl + \"/news/get-by-owner/{ownerId}?\";\n        if (ownerId === undefined || ownerId === null)\n            throw new Error(\"The parameter 'ownerId' must be defined.\");\n        url_ = url_.replace(\"{ownerId}\", encodeURIComponent(\"\" + ownerId)); \n        if (status === undefined || status === null)\n            throw new Error(\"The parameter 'status' must be defined and cannot be null.\");\n        else\n            url_ += \"status=\" + encodeURIComponent(\"\" + status) + \"&\"; \n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindNewsByOwner(_response);\n        });\n    }\n\n    protected processFindNewsByOwner(response: Response): Promise<FindNewsResultWithFollow> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FindNewsResultWithFollow>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FindNewsResultWithFollow>(<any>null);\n    }\n\n    /**\n     * Find news\n     * @param keyword (optional) search keyword\n     * @param state (optional) product state (old/new)\n     * @param priceType (optional) price type (fixed/negociate)\n     * @param minPrice (optional) min price\n     * @param maxPrice (optional) max price\n     * @param newsType (optional) news type (sell/buy/...)\n     * @param owner (optional) news owner id\n     * @param shop (optional) shop id\n     * @param location (optional) location (only by city)\n     * @param type (optional) product type (may ui/may xuc/may dao)\n     * @param brand (optional) product's brand\n     * @param model (optional) product model\n     * @param first number of records returned\n     * @param sortBy sort field\n     * @param before (optional) before token\n     * @param after (optional) after token\n     * @return successful operation\n     */\n    findNews(keyword: string | undefined, state: string | undefined, priceType: string | undefined, minPrice: number | undefined, maxPrice: number | undefined, newsType: string | undefined, owner: string | undefined, shop: string | undefined, location: string | undefined, type: string | undefined, brand: string | undefined, model: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindNewsResult> {\n        let url_ = this.baseUrl + \"/news?\";\n        if (keyword === null)\n            throw new Error(\"The parameter 'keyword' cannot be null.\");\n        else if (keyword !== undefined)\n            url_ += \"keyword=\" + encodeURIComponent(\"\" + keyword) + \"&\"; \n        if (state === null)\n            throw new Error(\"The parameter 'state' cannot be null.\");\n        else if (state !== undefined)\n            url_ += \"state=\" + encodeURIComponent(\"\" + state) + \"&\"; \n        if (priceType === null)\n            throw new Error(\"The parameter 'priceType' cannot be null.\");\n        else if (priceType !== undefined)\n            url_ += \"priceType=\" + encodeURIComponent(\"\" + priceType) + \"&\"; \n        if (minPrice === null)\n            throw new Error(\"The parameter 'minPrice' cannot be null.\");\n        else if (minPrice !== undefined)\n            url_ += \"minPrice=\" + encodeURIComponent(\"\" + minPrice) + \"&\"; \n        if (maxPrice === null)\n            throw new Error(\"The parameter 'maxPrice' cannot be null.\");\n        else if (maxPrice !== undefined)\n            url_ += \"maxPrice=\" + encodeURIComponent(\"\" + maxPrice) + \"&\"; \n        if (newsType === null)\n            throw new Error(\"The parameter 'newsType' cannot be null.\");\n        else if (newsType !== undefined)\n            url_ += \"newsType=\" + encodeURIComponent(\"\" + newsType) + \"&\"; \n        if (owner === null)\n            throw new Error(\"The parameter 'owner' cannot be null.\");\n        else if (owner !== undefined)\n            url_ += \"owner=\" + encodeURIComponent(\"\" + owner) + \"&\"; \n        if (shop === null)\n            throw new Error(\"The parameter 'shop' cannot be null.\");\n        else if (shop !== undefined)\n            url_ += \"shop=\" + encodeURIComponent(\"\" + shop) + \"&\"; \n        if (location === null)\n            throw new Error(\"The parameter 'location' cannot be null.\");\n        else if (location !== undefined)\n            url_ += \"location=\" + encodeURIComponent(\"\" + location) + \"&\"; \n        if (type === null)\n            throw new Error(\"The parameter 'type' cannot be null.\");\n        else if (type !== undefined)\n            url_ += \"type=\" + encodeURIComponent(\"\" + type) + \"&\"; \n        if (brand === null)\n            throw new Error(\"The parameter 'brand' cannot be null.\");\n        else if (brand !== undefined)\n            url_ += \"brand=\" + encodeURIComponent(\"\" + brand) + \"&\"; \n        if (model === null)\n            throw new Error(\"The parameter 'model' cannot be null.\");\n        else if (model !== undefined)\n            url_ += \"model=\" + encodeURIComponent(\"\" + model) + \"&\"; \n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindNews(_response);\n        });\n    }\n\n    protected processFindNews(response: Response): Promise<FindNewsResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FindNewsResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FindNewsResult>(<any>null);\n    }\n\n    /**\n     * Create news\n     * @param body (optional) \n     * @return successful operation\n     */\n    createNews(body: any | undefined): Promise<News> {\n        let url_ = this.baseUrl + \"/news\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCreateNews(_response);\n        });\n    }\n\n    protected processCreateNews(response: Response): Promise<News> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <News>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            let result201: any = null;\n            result201 = _responseText === \"\" ? null : <News>JSON.parse(_responseText, this.jsonParseReviver);\n            return result201;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<News>(<any>null);\n    }\n\n    /**\n     * Find brands\n     * @param search (optional) search query to filter brands\n     * @param first search query to filter brands\n     * @param sortBy search query to filter brands\n     * @param before (optional) before token\n     * @param after (optional) after token\n     * @return successful operation\n     */\n    findBrands(search: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindBrandsResult> {\n        let url_ = this.baseUrl + \"/brands?\";\n        if (search === null)\n            throw new Error(\"The parameter 'search' cannot be null.\");\n        else if (search !== undefined)\n            url_ += \"search=\" + encodeURIComponent(\"\" + search) + \"&\"; \n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindBrands(_response);\n        });\n    }\n\n    protected processFindBrands(response: Response): Promise<FindBrandsResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FindBrandsResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FindBrandsResult>(<any>null);\n    }\n\n    /**\n     * Create brand\n     * @param body (optional) \n     * @return successful operation\n     */\n    createBrand(body: any | undefined): Promise<Brand> {\n        let url_ = this.baseUrl + \"/brands\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCreateBrand(_response);\n        });\n    }\n\n    protected processCreateBrand(response: Response): Promise<Brand> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Brand>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            let result201: any = null;\n            result201 = _responseText === \"\" ? null : <Brand>JSON.parse(_responseText, this.jsonParseReviver);\n            return result201;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Brand>(<any>null);\n    }\n\n    /**\n     * Find brands list\n     * @return successful operation\n     */\n    findBrandList(): Promise<FindBrandsResult> {\n        let url_ = this.baseUrl + \"/brands/customs/find-brand-list\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindBrandList(_response);\n        });\n    }\n\n    protected processFindBrandList(response: Response): Promise<FindBrandsResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FindBrandsResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FindBrandsResult>(<any>null);\n    }\n\n    /**\n     * Find brand detail by slug\n     * @param brandSlug brandSlug\n     * @return successful operation\n     */\n    findBrandDetail(brandSlug: string): Promise<Brand> {\n        let url_ = this.baseUrl + \"/brands/customs/find-brand-detail/{brandSlug}\";\n        if (brandSlug === undefined || brandSlug === null)\n            throw new Error(\"The parameter 'brandSlug' must be defined.\");\n        url_ = url_.replace(\"{brandSlug}\", encodeURIComponent(\"\" + brandSlug)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindBrandDetail(_response);\n        });\n    }\n\n    protected processFindBrandDetail(response: Response): Promise<Brand> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Brand>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Brand>(<any>null);\n    }\n\n    /**\n     * Find top brands\n     * @return successful operation\n     */\n    findTopBrands(): Promise<FindBrandsResult> {\n        let url_ = this.baseUrl + \"/brands/customs/find-top-brands\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindTopBrands(_response);\n        });\n    }\n\n    protected processFindTopBrands(response: Response): Promise<FindBrandsResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FindBrandsResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FindBrandsResult>(<any>null);\n    }\n\n    /**\n     * Find brand by id\n     * @param brandId brandId\n     * @return successful operation\n     */\n    findBrandById(brandId: string): Promise<Brand> {\n        let url_ = this.baseUrl + \"/brands/{brandId}\";\n        if (brandId === undefined || brandId === null)\n            throw new Error(\"The parameter 'brandId' must be defined.\");\n        url_ = url_.replace(\"{brandId}\", encodeURIComponent(\"\" + brandId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindBrandById(_response);\n        });\n    }\n\n    protected processFindBrandById(response: Response): Promise<Brand> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Brand>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Brand>(<any>null);\n    }\n\n    /**\n     * Update brand\n     * @param brandId brandId\n     * @param body (optional) \n     * @return successful operation\n     */\n    updateBrand(brandId: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/brands/{brandId}\";\n        if (brandId === undefined || brandId === null)\n            throw new Error(\"The parameter 'brandId' must be defined.\");\n        url_ = url_.replace(\"{brandId}\", encodeURIComponent(\"\" + brandId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processUpdateBrand(_response);\n        });\n    }\n\n    protected processUpdateBrand(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Find categories\n     * @return successful operation\n     */\n    findCategories(): Promise<FindCategoriesResult> {\n        let url_ = this.baseUrl + \"/categories\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindCategories(_response);\n        });\n    }\n\n    protected processFindCategories(response: Response): Promise<FindCategoriesResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FindCategoriesResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FindCategoriesResult>(<any>null);\n    }\n\n    /**\n     * Create category\n     * @param body (optional) \n     * @return successful operation\n     */\n    createCategory(body: any | undefined): Promise<Category> {\n        let url_ = this.baseUrl + \"/categories\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCreateCategory(_response);\n        });\n    }\n\n    protected processCreateCategory(response: Response): Promise<Category> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Category>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            let result201: any = null;\n            result201 = _responseText === \"\" ? null : <Category>JSON.parse(_responseText, this.jsonParseReviver);\n            return result201;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Category>(<any>null);\n    }\n\n    /**\n     * Find category detail by slug\n     * @param categorySlug categorySlug\n     * @return successful operation\n     */\n    findCategoryDetail(categorySlug: string): Promise<Category> {\n        let url_ = this.baseUrl + \"/categories/customs/find-category-detail/{categorySlug}\";\n        if (categorySlug === undefined || categorySlug === null)\n            throw new Error(\"The parameter 'categorySlug' must be defined.\");\n        url_ = url_.replace(\"{categorySlug}\", encodeURIComponent(\"\" + categorySlug)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindCategoryDetail(_response);\n        });\n    }\n\n    protected processFindCategoryDetail(response: Response): Promise<Category> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Category>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Category>(<any>null);\n    }\n\n    /**\n     * Find category by id\n     * @param categoryId categoryId\n     * @return successful operation\n     */\n    findCategoryById(categoryId: string): Promise<Category> {\n        let url_ = this.baseUrl + \"/categories/{categoryId}\";\n        if (categoryId === undefined || categoryId === null)\n            throw new Error(\"The parameter 'categoryId' must be defined.\");\n        url_ = url_.replace(\"{categoryId}\", encodeURIComponent(\"\" + categoryId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindCategoryById(_response);\n        });\n    }\n\n    protected processFindCategoryById(response: Response): Promise<Category> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Category>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Category>(<any>null);\n    }\n\n    /**\n     * Update category\n     * @param categoryId categoryId\n     * @param body (optional) \n     * @return successful operation\n     */\n    updateCategory(categoryId: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/categories/{categoryId}\";\n        if (categoryId === undefined || categoryId === null)\n            throw new Error(\"The parameter 'categoryId' must be defined.\");\n        url_ = url_.replace(\"{categoryId}\", encodeURIComponent(\"\" + categoryId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processUpdateCategory(_response);\n        });\n    }\n\n    protected processUpdateCategory(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Find models\n     * @param search (optional) search string\n     * @param brand (optional) brand\n     * @param category (optional) category\n     * @param first search query to filter brands\n     * @param sortBy search query to filter brands\n     * @param before (optional) before token\n     * @param after (optional) after token\n     * @return successful operation\n     */\n    findModels(search: string | undefined, brand: string | undefined, category: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<FindModelsResult> {\n        let url_ = this.baseUrl + \"/models?\";\n        if (search === null)\n            throw new Error(\"The parameter 'search' cannot be null.\");\n        else if (search !== undefined)\n            url_ += \"search=\" + encodeURIComponent(\"\" + search) + \"&\"; \n        if (brand === null)\n            throw new Error(\"The parameter 'brand' cannot be null.\");\n        else if (brand !== undefined)\n            url_ += \"brand=\" + encodeURIComponent(\"\" + brand) + \"&\"; \n        if (category === null)\n            throw new Error(\"The parameter 'category' cannot be null.\");\n        else if (category !== undefined)\n            url_ += \"category=\" + encodeURIComponent(\"\" + category) + \"&\"; \n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindModels(_response);\n        });\n    }\n\n    protected processFindModels(response: Response): Promise<FindModelsResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FindModelsResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FindModelsResult>(<any>null);\n    }\n\n    /**\n     * Create model\n     * @param body (optional) \n     * @return successful operation\n     */\n    createModel(body: any | undefined): Promise<Model> {\n        let url_ = this.baseUrl + \"/models\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCreateModel(_response);\n        });\n    }\n\n    protected processCreateModel(response: Response): Promise<Model> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Model>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            let result201: any = null;\n            result201 = _responseText === \"\" ? null : <Model>JSON.parse(_responseText, this.jsonParseReviver);\n            return result201;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Model>(<any>null);\n    }\n\n    /**\n     * Find model by id\n     * @param modelId modelId\n     * @return successful operation\n     */\n    findModelById(modelId: string): Promise<Model> {\n        let url_ = this.baseUrl + \"/models/{modelId}\";\n        if (modelId === undefined || modelId === null)\n            throw new Error(\"The parameter 'modelId' must be defined.\");\n        url_ = url_.replace(\"{modelId}\", encodeURIComponent(\"\" + modelId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindModelById(_response);\n        });\n    }\n\n    protected processFindModelById(response: Response): Promise<Model> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Model>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Model>(<any>null);\n    }\n\n    /**\n     * Update model\n     * @param modelId modelId\n     * @param body (optional) \n     * @return successful operation\n     */\n    updateModel(modelId: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/models/{modelId}\";\n        if (modelId === undefined || modelId === null)\n            throw new Error(\"The parameter 'modelId' must be defined.\");\n        url_ = url_.replace(\"{modelId}\", encodeURIComponent(\"\" + modelId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processUpdateModel(_response);\n        });\n    }\n\n    protected processUpdateModel(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Find provinces\n     * @return successful operation\n     */\n    findProvinces(): Promise<FindProvincesResult> {\n        let url_ = this.baseUrl + \"/provinces\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindProvinces(_response);\n        });\n    }\n\n    protected processFindProvinces(response: Response): Promise<FindProvincesResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <FindProvincesResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<FindProvincesResult>(<any>null);\n    }\n\n    /**\n     * Create province\n     * @param body (optional) \n     * @return successful operation\n     */\n    createProvince(body: any | undefined): Promise<Province> {\n        let url_ = this.baseUrl + \"/provinces\";\n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processCreateProvince(_response);\n        });\n    }\n\n    protected processCreateProvince(response: Response): Promise<Province> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Province>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            let result201: any = null;\n            result201 = _responseText === \"\" ? null : <Province>JSON.parse(_responseText, this.jsonParseReviver);\n            return result201;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Province>(<any>null);\n    }\n\n    /**\n     * Find province by id\n     * @param provinceId provinceId\n     * @return successful operation\n     */\n    findProvinceById(provinceId: string): Promise<Province> {\n        let url_ = this.baseUrl + \"/provinces/{provinceId}\";\n        if (provinceId === undefined || provinceId === null)\n            throw new Error(\"The parameter 'provinceId' must be defined.\");\n        url_ = url_.replace(\"{provinceId}\", encodeURIComponent(\"\" + provinceId)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindProvinceById(_response);\n        });\n    }\n\n    protected processFindProvinceById(response: Response): Promise<Province> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <Province>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<Province>(<any>null);\n    }\n\n    /**\n     * Update province\n     * @param province provinceId\n     * @param body (optional) \n     * @return successful operation\n     */\n    updateProvince(province: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/provinces/{provinceId}\";\n        if (province === undefined || province === null)\n            throw new Error(\"The parameter 'province' must be defined.\");\n        url_ = url_.replace(\"{province}\", encodeURIComponent(\"\" + province)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processUpdateProvince(_response);\n        });\n    }\n\n    protected processUpdateProvince(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Search by elasticsearch\n     * @param keyword (optional) search keyword\n     * @param state (optional) product state (old/new)\n     * @param priceType (optional) price type (fixed/negociate)\n     * @param minPrice (optional) min price\n     * @param maxPrice (optional) max price\n     * @param weightRange (optional) weight range\n     * @param otherNewsType (optional) news type (sell/buy/...)\n     * @param newsType (optional) news type (sell/buy/...)\n     * @param categoryId (optional) categoryID\n     * @param owner (optional) news owner id\n     * @param shop (optional) shop id\n     * @param location (optional) location (only by city)\n     * @param type (optional) product type (may ui/may xuc/may dao)\n     * @param brand (optional) product's brand\n     * @param model (optional) product model\n     * @param first number of records returned\n     * @param sortBy sort field\n     * @param before (optional) before token\n     * @param after (optional) after token\n     * @return successful operation\n     */\n    searchElasticsearch(keyword: string | undefined, state: string | undefined, priceType: string | undefined, minPrice: number | undefined, maxPrice: number | undefined, weightRange: string | undefined, otherNewsType: string | undefined, newsType: string | undefined, categoryId: string | undefined, owner: string | undefined, shop: string | undefined, location: string | undefined, type: string | undefined, brand: string | undefined, model: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<ElasticSearchResult> {\n        let url_ = this.baseUrl + \"/search?\";\n        if (keyword === null)\n            throw new Error(\"The parameter 'keyword' cannot be null.\");\n        else if (keyword !== undefined)\n            url_ += \"keyword=\" + encodeURIComponent(\"\" + keyword) + \"&\"; \n        if (state === null)\n            throw new Error(\"The parameter 'state' cannot be null.\");\n        else if (state !== undefined)\n            url_ += \"state=\" + encodeURIComponent(\"\" + state) + \"&\"; \n        if (priceType === null)\n            throw new Error(\"The parameter 'priceType' cannot be null.\");\n        else if (priceType !== undefined)\n            url_ += \"priceType=\" + encodeURIComponent(\"\" + priceType) + \"&\"; \n        if (minPrice === null)\n            throw new Error(\"The parameter 'minPrice' cannot be null.\");\n        else if (minPrice !== undefined)\n            url_ += \"minPrice=\" + encodeURIComponent(\"\" + minPrice) + \"&\"; \n        if (maxPrice === null)\n            throw new Error(\"The parameter 'maxPrice' cannot be null.\");\n        else if (maxPrice !== undefined)\n            url_ += \"maxPrice=\" + encodeURIComponent(\"\" + maxPrice) + \"&\"; \n        if (weightRange === null)\n            throw new Error(\"The parameter 'weightRange' cannot be null.\");\n        else if (weightRange !== undefined)\n            url_ += \"weightRange=\" + encodeURIComponent(\"\" + weightRange) + \"&\"; \n        if (otherNewsType === null)\n            throw new Error(\"The parameter 'otherNewsType' cannot be null.\");\n        else if (otherNewsType !== undefined)\n            url_ += \"otherNewsType=\" + encodeURIComponent(\"\" + otherNewsType) + \"&\"; \n        if (newsType === null)\n            throw new Error(\"The parameter 'newsType' cannot be null.\");\n        else if (newsType !== undefined)\n            url_ += \"newsType=\" + encodeURIComponent(\"\" + newsType) + \"&\"; \n        if (categoryId === null)\n            throw new Error(\"The parameter 'categoryId' cannot be null.\");\n        else if (categoryId !== undefined)\n            url_ += \"categoryId=\" + encodeURIComponent(\"\" + categoryId) + \"&\"; \n        if (owner === null)\n            throw new Error(\"The parameter 'owner' cannot be null.\");\n        else if (owner !== undefined)\n            url_ += \"owner=\" + encodeURIComponent(\"\" + owner) + \"&\"; \n        if (shop === null)\n            throw new Error(\"The parameter 'shop' cannot be null.\");\n        else if (shop !== undefined)\n            url_ += \"shop=\" + encodeURIComponent(\"\" + shop) + \"&\"; \n        if (location === null)\n            throw new Error(\"The parameter 'location' cannot be null.\");\n        else if (location !== undefined)\n            url_ += \"location=\" + encodeURIComponent(\"\" + location) + \"&\"; \n        if (type === null)\n            throw new Error(\"The parameter 'type' cannot be null.\");\n        else if (type !== undefined)\n            url_ += \"type=\" + encodeURIComponent(\"\" + type) + \"&\"; \n        if (brand === null)\n            throw new Error(\"The parameter 'brand' cannot be null.\");\n        else if (brand !== undefined)\n            url_ += \"brand=\" + encodeURIComponent(\"\" + brand) + \"&\"; \n        if (model === null)\n            throw new Error(\"The parameter 'model' cannot be null.\");\n        else if (model !== undefined)\n            url_ += \"model=\" + encodeURIComponent(\"\" + model) + \"&\"; \n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processSearchElasticsearch(_response);\n        });\n    }\n\n    protected processSearchElasticsearch(response: Response): Promise<ElasticSearchResult> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <ElasticSearchResult>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<ElasticSearchResult>(<any>null);\n    }\n\n    /**\n     * Follow\n     * @param id newsId\n     * @param body (optional) \n     * @return successful operation\n     */\n    follow(id: string, body: any | undefined): Promise<void> {\n        let url_ = this.baseUrl + \"/follows/{id}\";\n        if (id === undefined || id === null)\n            throw new Error(\"The parameter 'id' must be defined.\");\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id)); \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        const content_ = JSON.stringify(body);\n\n        let options_ = <RequestInit>{\n            body: content_,\n            method: \"PATCH\",\n            headers: {\n                \"Content-Type\": \"application/json\", \n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFollow(_response);\n        });\n    }\n\n    protected processFollow(response: Response): Promise<void> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 201) {\n            return response.text().then((_responseText) => {\n            return;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<void>(<any>null);\n    }\n\n    /**\n     * Find follow by user/news\n     * @param id id\n     * @param type type\n     * @param newsType (optional) type\n     * @param first first\n     * @param sortBy sortBy\n     * @param before (optional) before\n     * @param after (optional) after\n     * @return successful operation\n     */\n    findFollow(id: string, type: string, newsType: string | undefined, first: number, sortBy: string, before: string | undefined, after: string | undefined): Promise<any> {\n        let url_ = this.baseUrl + \"/follows?\";\n        if (id === undefined || id === null)\n            throw new Error(\"The parameter 'id' must be defined and cannot be null.\");\n        else\n            url_ += \"id=\" + encodeURIComponent(\"\" + id) + \"&\"; \n        if (type === undefined || type === null)\n            throw new Error(\"The parameter 'type' must be defined and cannot be null.\");\n        else\n            url_ += \"type=\" + encodeURIComponent(\"\" + type) + \"&\"; \n        if (newsType === null)\n            throw new Error(\"The parameter 'newsType' cannot be null.\");\n        else if (newsType !== undefined)\n            url_ += \"newsType=\" + encodeURIComponent(\"\" + newsType) + \"&\"; \n        if (first === undefined || first === null)\n            throw new Error(\"The parameter 'first' must be defined and cannot be null.\");\n        else\n            url_ += \"first=\" + encodeURIComponent(\"\" + first) + \"&\"; \n        if (sortBy === undefined || sortBy === null)\n            throw new Error(\"The parameter 'sortBy' must be defined and cannot be null.\");\n        else\n            url_ += \"sortBy=\" + encodeURIComponent(\"\" + sortBy) + \"&\"; \n        if (before === null)\n            throw new Error(\"The parameter 'before' cannot be null.\");\n        else if (before !== undefined)\n            url_ += \"before=\" + encodeURIComponent(\"\" + before) + \"&\"; \n        if (after === null)\n            throw new Error(\"The parameter 'after' cannot be null.\");\n        else if (after !== undefined)\n            url_ += \"after=\" + encodeURIComponent(\"\" + after) + \"&\"; \n        url_ = url_.replace(/[?&]$/, \"\");\n\n        let options_ = <RequestInit>{\n            method: \"GET\",\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        };\n\n        return this.http.fetch(url_, options_).then((_response: Response) => {\n            return this.processFindFollow(_response);\n        });\n    }\n\n    protected processFindFollow(response: Response): Promise<any> {\n        const status = response.status;\n        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };\n        if (status === 200) {\n            return response.text().then((_responseText) => {\n            let result200: any = null;\n            result200 = _responseText === \"\" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);\n            return result200;\n            });\n        } else if (status === 400) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 401) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status === 500) {\n            return response.text().then((_responseText) => {\n            return throwException(\"A server error occurred.\", status, _responseText, _headers);\n            });\n        } else if (status !== 200 && status !== 204) {\n            return response.text().then((_responseText) => {\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n            });\n        }\n        return Promise.resolve<any>(<any>null);\n    }\n}\n\nexport interface GetAllRolesResult {\n    roles: Role[];\n}\n\nexport interface CheckPhoneNoExistResult {\n    phoneNoExist: boolean;\n}\n\nexport interface CheckRoleNameExistResult {\n    roleNameExist: boolean;\n}\n\nexport interface RegisterUserPayload {\n    idToken: string;\n}\n\nexport interface FindRolesResult {\n    data: Role[];\n    before: any;\n    after: any;\n}\n\nexport interface ActivateRolePayload {\n    operation: ActivateRolePayloadOperation;\n}\n\nexport interface DeactivateRolePayload {\n    operation: DeactivateRolePayloadOperation;\n}\n\nexport interface UpdateRolePayload {\n    operation: UpdateRolePayloadOperation;\n    payload: Payload;\n}\n\nexport interface Role {\n    _id: string;\n    name: string;\n    description: string;\n    permissions: string[];\n}\n\nexport interface CreateRolePayload {\n    name: string;\n    description: string;\n    permissions: string[];\n}\n\nexport interface FindUserResult {\n    data: User[];\n    before: any;\n    after: any;\n    roles: any[];\n    completeSignUp: boolean;\n    isActive: boolean;\n    isDeleted: boolean;\n    lastModifiedAt: any;\n    _id: string;\n    permissions: any[];\n    email: string;\n    createdBy: string;\n    createdAt: any;\n    followBy: any[];\n}\n\nexport interface FacebookLogin {\n    uid: string;\n    email: string;\n    provider: FacebookLoginProvider;\n}\n\nexport interface GoogleLogin {\n    uid: string;\n    email: string;\n    provider: GoogleLoginProvider;\n}\n\nexport interface PhoneLogin {\n    phoneNo: string;\n    provider: PhoneLoginProvider;\n}\n\nexport interface EmailLogin {\n    email: string;\n    provider: EmailLoginProvider;\n}\n\nexport interface User {\n    _id: string;\n    email: string;\n    familyName: string;\n    givenName: string;\n    fullName: string;\n    phoneNo: string;\n    address: string;\n    description: string;\n    avatarUrl: string;\n    province: string;\n    dob: number;\n    gender: string;\n    loginDetail: any;\n    roles: string[];\n    completeSignUp: boolean;\n    followBy: any[];\n    isActive: boolean;\n    createdAt: number;\n    createdBy: number;\n    counterFollow: number;\n    isFollowing: boolean;\n}\n\nexport interface CheckEmailExistResult {\n    emailExist: boolean;\n}\n\nexport interface UpdateUserPayload {\n    operation: UpdateUserPayloadOperation;\n    payload: Payload2;\n}\n\nexport interface UpdateProfilePayload {\n    operation: UpdateProfilePayloadOperation;\n    payload: Payload3;\n}\n\nexport interface ChangePasswordPayload {\n    newPassword: string;\n}\n\nexport interface ActivateUserPayload {\n    operation: ActivateUserPayloadOperation;\n}\n\nexport interface DeactivateUserPayload {\n    operation: DeactivateUserPayloadOperation;\n}\n\nexport interface UpdateAvatarPayload {\n    operation: UpdateAvatarPayloadOperation;\n    data: Data;\n}\n\nexport interface CreateUserPayload {\n    email: string;\n    password: string;\n    roles: string[];\n    familyName: string;\n    givenName: string;\n}\n\nexport interface NewsStatisticsResult {\n    daysOfWeek: DaysOfWeek[];\n    hoursOfDay: HoursOfDay[];\n    brands: Brand[];\n    categories: Category[];\n    provinces: Province[];\n}\n\nexport interface UpdateAdsensePayload {\n    operation: UpdateAdsensePayloadOperation;\n    payload: Payload4;\n}\n\nexport interface CreateAdsensePayload {\n    name: string;\n    imageUrl: string;\n    hyperlink: string;\n    position: number;\n}\n\nexport interface GetAdsenseResult {\n    data: Adsense[];\n}\n\nexport interface Adsense {\n    _id: string;\n    name: string;\n    imageUrl: string;\n    hyperlink: string;\n    position: number;\n    createdAt: number;\n}\n\nexport interface UpdateFeatureBrandPayload {\n    operation: UpdateFeatureBrandPayloadOperation;\n    payload: Payload5;\n}\n\nexport interface GetFeatureBrandsResult {\n    data: FeatureBrand[];\n    before: string;\n    after: string;\n}\n\nexport interface CreateFeatureBrandPayload {\n    brand: string;\n    logoImage: string;\n    hyperlink: string;\n    order: number;\n}\n\nexport interface FeatureBrand {\n    _id: string;\n    brand: any;\n    logoImage: string;\n    hyperlink: string;\n    order: number;\n    createdAt: number;\n}\n\nexport interface CreateRentalPeriodPayload {\n    min: number;\n    max: number;\n}\n\nexport interface UpdateRentalPeriodPayload {\n    operation: UpdateRentalPeriodPayloadOperation;\n    payload: Payload6;\n}\n\nexport interface UpdateWeightRangePayload {\n    operation: UpdateWeightRangePayloadOperation;\n    payload: Payload7;\n}\n\nexport interface CreateWeightRangePayload {\n    min: number;\n    max: number;\n}\n\nexport interface RentalPeriod {\n    _id: string;\n    min: number;\n    max: number;\n    createdAt: number;\n}\n\nexport interface GetAllRentalPeriodsResult {\n    data: RentalPeriod[];\n}\n\nexport interface WeightRange {\n    _id: string;\n    min: number;\n    max: number;\n    createdAt: number;\n}\n\nexport interface GetAllWeightRangesResult {\n    data: WeightRange[];\n}\n\nexport interface CommonKeyword {\n    keyword: string;\n    count: number;\n    createdAt: number;\n}\n\nexport interface GetCommonKeywordsResult {\n    data: CommonKeyword[];\n    before: string;\n    after: string;\n}\n\nexport interface CreateRecentViewedPayload {\n    news: string;\n}\n\nexport interface RecentViewedItem {\n    _id: string;\n    uuid: string;\n    user: string;\n    news: any;\n    createdAt: number;\n    lastModifiedAt: number;\n}\n\nexport interface GetRecentViewedResult {\n    data: RecentViewedItem[];\n    before: string;\n    after: string;\n}\n\nexport interface SearchNewsMostFollowResult {\n    data: SearchNewsMostFollowItemResult[];\n    before: string;\n    after: string;\n}\n\nexport interface ReadNotificationPayload {\n    operation: ReadNotificationPayloadOperation;\n    payload: Payload8;\n}\n\nexport interface ReadAllNotificationsPayload {\n    operation: ReadAllNotificationsPayloadOperation;\n}\n\nexport interface CountUnreadNotificationsResult {\n    unreadNotifications: number;\n}\n\nexport interface Notification {\n    _id: string;\n    owner: any;\n    news: any;\n    state: NotificationState;\n    type: NotificationType;\n    createdAt: number;\n}\n\nexport interface FindNotificationsResult {\n    data: Notification[];\n    before: string;\n    after: string;\n}\n\nexport interface SearchNewsMostFollowItemResult {\n    _id: string;\n    imageUrls: string[];\n    isDeleted: boolean;\n    lastModifiedAt: number;\n    isFollowing: boolean;\n    title: string;\n    state: string;\n    newsType: string;\n    counterFollow: number;\n    counterView: number;\n}\n\nexport interface FindReportsResult {\n    data: Report[];\n    before: string;\n    after: string;\n}\n\nexport interface UpdateReportPayload {\n    operation: UpdateReportPayloadOperation;\n    payload: Payload9;\n}\n\nexport interface Report {\n    _id: any;\n    news: any;\n    reports: Reports[];\n    state: ReportState;\n    resolvedResult: ReportResolvedResult;\n    resolvedBy: any;\n    resolvedAt: number;\n}\n\nexport interface CreateReportPayload {\n    news: string;\n    reason: CreateReportPayloadReason;\n    description: string;\n    email: string;\n    phoneNo: string;\n}\n\nexport interface UpdateIntroImagesShopPayload {\n    operation: UpdateIntroImagesShopPayloadOperation;\n    payload: Payload10;\n}\n\nexport interface UpdateLogoImageShopPayload {\n    operation: UpdateLogoImageShopPayloadOperation;\n    payload: Payload11;\n}\n\nexport interface DeactivateShopPayload {\n    operation: DeactivateShopPayloadOperation;\n}\n\nexport interface ActivateShopPayload {\n    operation: ActivateShopPayloadOperation;\n}\n\nexport interface UpdateShopPayload {\n    operation: UpdateShopPayloadOperation;\n    payload: Payload12;\n}\n\nexport interface CreateShopPayload {\n    owner: string;\n    domain: string;\n    name: string;\n    email: string;\n    address: string;\n    geocode: Geocode;\n    description: string;\n    phone: string;\n    introImages: string[];\n    logoImage: string;\n    expiryDate: number;\n}\n\nexport interface FindShopsResult {\n    data: Shop[];\n    before: string;\n    after: string;\n}\n\nexport interface Shop {\n    _id: string;\n    owner: any;\n    domain: string;\n    name: string;\n    address: string;\n    geocode: Geocode2;\n    description: string;\n    followBy: any[];\n    isFollowing: boolean;\n    phone: string;\n    email: string;\n    introImages: string[];\n    logoImage: string;\n}\n\nexport interface ElasticSearchResult {\n    data: ElasticSearchItemResult[];\n    before: string;\n    after: string;\n}\n\nexport interface ElasticSearchItemResult {\n    title: string;\n    state: string;\n    description: string;\n    imageUrls: string[];\n    price: number;\n    priceType: string;\n    newsType: string;\n    owner: string;\n    location: Location;\n    status: string;\n    usedHours: number;\n    serialNo: number;\n    categoryId: CategoryId;\n    brand: Brand2;\n    model: Model2;\n    weight: number;\n    year: number;\n    followBy: string[];\n    isDeleted: boolean;\n    createdBy: number;\n    createdAt: number;\n    lastModifiedAt: number;\n    elasticsearchID: string;\n    elasticsearchTitle: string;\n    isFollowing: boolean;\n    _id: string;\n}\n\nexport interface News {\n    _id: string;\n    title: string;\n    state: string;\n    description: string;\n    imageUrls: string[];\n    price: number;\n    priceType: string;\n    newsType: string;\n    owner: any;\n    shop: any;\n    location: any;\n    status: string;\n    usedHours: number;\n    serialNo: string;\n    categoryId: any;\n    type: any;\n    brand: any;\n    model: any;\n    weight: number;\n    year: number;\n    weightRange: any;\n    rentalPeriod: any;\n    followBy: any[];\n    isFollowing: boolean;\n    createdAt: number;\n    counterFollow: number;\n    counterView: number;\n}\n\nexport interface FindNewsDetail {\n    _id: string;\n    title: string;\n    state: string;\n    description: string;\n    imageUrls: string[];\n    price: number;\n    priceType: string;\n    newsType: string;\n    owner: any;\n    shop: any;\n    location: any;\n    status: string;\n    usedHours: number;\n    serialNo: string;\n    categoryId: any;\n    type: any;\n    brand: any;\n    model: any;\n    weight: number;\n    year: number;\n    weightRange: any;\n    rentalPeriod: any;\n    followBy: any[];\n    isFollowing: boolean;\n    createdAt: number;\n    counterView: number;\n    counterFollow: number;\n}\n\nexport interface CreateNewsPayload {\n    title: string;\n    state: string;\n    newsType: string;\n    priceType: string;\n    location: string;\n    owner: string;\n    status: string;\n    usedHours: number;\n    serialNo: string;\n    categoryId: string;\n    type: string;\n    brand: string;\n    model: string;\n    weight: number;\n    year: number;\n}\n\nexport interface UpdateNewsPayload {\n    operation: string;\n    data: Data2;\n}\n\nexport interface FindNewsResult {\n    data: News[];\n    before: string;\n    after: string;\n}\n\nexport interface FindNewsResultWithFollow {\n    data: FindNewsDetail[];\n    before: string;\n    after: string;\n}\n\nexport interface Brand {\n    _id: string;\n    slug: string;\n    name: string;\n    logoImage: string;\n    totalNews: number;\n    brandCategories: Category[];\n    brandModels: Model[];\n    createdAt: number;\n}\n\nexport interface FindBrandsResult {\n    data: Brand[];\n    before: string;\n    after: string;\n}\n\nexport interface CreateBrandPayload {\n    name: string;\n    logoImage: string;\n}\n\nexport interface UpdateBrandPayload {\n    operation: UpdateBrandPayloadOperation;\n    payload: any;\n}\n\nexport interface Category {\n    _id: string;\n    slug: string;\n    name: string;\n    imageUrl: string;\n    totalNews: number;\n    categoryBrands: Brand[];\n    categoryModels: Model[];\n    createdAt: number;\n}\n\nexport interface FindCategoriesResult {\n    data: Category[];\n}\n\nexport interface CreateCategoryPayload {\n    name: string;\n    imageUrl: string;\n}\n\nexport interface UpdateCategoryPayload {\n    operation: UpdateCategoryPayloadOperation;\n    payload: Payload13;\n}\n\nexport interface Model {\n    _id: string;\n    slug: string;\n    name: string;\n    brand: any;\n    category: any;\n    totalNews: number;\n    createdAt: number;\n}\n\nexport interface FindModelsResult {\n    data: Model[];\n    before: string;\n    after: string;\n}\n\nexport interface CreateModelPayload {\n    name: string;\n    slug: string;\n    brand: string;\n    model: string;\n}\n\nexport interface UpdateModelPayload {\n    _id: string;\n    name: string;\n    slug: string;\n    brand: string;\n    model: string;\n}\n\nexport interface Province {\n    _id: string;\n    slug: string;\n    name: string;\n    totalNews: number;\n}\n\nexport interface FindProvincesResult {\n    data: Province[];\n}\n\nexport interface CreateProvincePayload {\n    name: string;\n    slug: string;\n}\n\nexport interface UpdateProvincePayload {\n    _id: string;\n    name: string;\n    slug: string;\n}\n\nexport interface FollowPayload {\n    operation: string;\n    payload: Payload14;\n}\n\nexport interface FindUserFollowResult {\n    data: FindUserResult[];\n}\n\nexport enum State {\n    PENDING = \"PENDING\", \n    RESOLVED = \"RESOLVED\", \n}\n\nexport enum Reason {\n    WRONG_INFO = \"WRONG_INFO\", \n    SOLD = \"SOLD\", \n    VIOLATE = \"VIOLATE\", \n}\n\nexport enum ActivateRolePayloadOperation {\n    Activate = \"activate\", \n}\n\nexport enum DeactivateRolePayloadOperation {\n    Deactivate = \"deactivate\", \n}\n\nexport enum UpdateRolePayloadOperation {\n    UpdateDetail = \"updateDetail\", \n}\n\nexport interface Payload {\n    name: string;\n    description: string;\n    permissions: string[];\n}\n\nexport enum FacebookLoginProvider {\n    Facebook = \"facebook\", \n}\n\nexport enum GoogleLoginProvider {\n    Google = \"google\", \n}\n\nexport enum PhoneLoginProvider {\n    Phone = \"phone\", \n}\n\nexport enum EmailLoginProvider {\n    Email = \"email\", \n}\n\nexport enum UpdateUserPayloadOperation {\n    UpdateDetail = \"updateDetail\", \n}\n\nexport interface Payload2 {\n    roles: string[];\n    familyName: string;\n    givenName: string;\n    email: string;\n}\n\nexport enum UpdateProfilePayloadOperation {\n    UpdateDetail = \"updateDetail\", \n}\n\nexport interface Payload3 {\n    familyName: string;\n    givenName: string;\n    phoneNo: string;\n    email: string;\n    address: string;\n    description: string;\n}\n\nexport enum ActivateUserPayloadOperation {\n    Activate = \"activate\", \n}\n\nexport enum DeactivateUserPayloadOperation {\n    Deactivate = \"deactivate\", \n}\n\nexport enum UpdateAvatarPayloadOperation {\n    UpdateAvatar = \"updateAvatar\", \n}\n\nexport interface Data {\n    avatarUrl: string;\n}\n\nexport interface DaysOfWeek {\n    _id: number;\n    totalNews: number;\n}\n\nexport interface HoursOfDay {\n    _id: number;\n    totalNews: number;\n}\n\nexport enum UpdateAdsensePayloadOperation {\n    UpdateDetail = \"updateDetail\", \n}\n\nexport interface Payload4 {\n    name: string;\n    imageUrl: string;\n    hyperlink: string;\n    position: number;\n}\n\nexport enum UpdateFeatureBrandPayloadOperation {\n    UpdateDetail = \"updateDetail\", \n}\n\nexport interface Payload5 {\n    brand: string;\n    logoImage: string;\n    hyperlink: string;\n    order: number;\n}\n\nexport enum UpdateRentalPeriodPayloadOperation {\n    UpdateDetail = \"updateDetail\", \n}\n\nexport interface Payload6 {\n    min: number;\n    max: number;\n}\n\nexport enum UpdateWeightRangePayloadOperation {\n    UpdateDetail = \"updateDetail\", \n}\n\nexport interface Payload7 {\n    min: number;\n    max: number;\n}\n\nexport enum ReadNotificationPayloadOperation {\n    ReadNotification = \"readNotification\", \n}\n\nexport interface Payload8 {\n    notificationId: string;\n}\n\nexport enum ReadAllNotificationsPayloadOperation {\n    ReadAllNotifications = \"readAllNotifications\", \n}\n\nexport enum NotificationState {\n    READ = \"READ\", \n    UNREAD = \"UNREAD\", \n}\n\nexport enum NotificationType {\n    FOLLOW_USER = \"FOLLOW_USER\", \n    FOLLOW_SHOP = \"FOLLOW_SHOP\", \n    CREATE_NEWS = \"CREATE_NEWS\", \n}\n\nexport enum UpdateReportPayloadOperation {\n    ResolveReport = \"resolveReport\", \n}\n\nexport interface Payload9 {\n    resolvedResult: Payload9ResolvedResult;\n}\n\nexport interface Reports {\n    reason: ReportsReason;\n    description: string;\n    email: string;\n    phoneNo: string;\n    createdAt: number;\n}\n\nexport enum ReportState {\n    PENDING = \"PENDING\", \n    RESOLVED = \"RESOLVED\", \n}\n\nexport enum ReportResolvedResult {\n    SKIP = \"SKIP\", \n    DELETE = \"DELETE\", \n}\n\nexport enum CreateReportPayloadReason {\n    WRONG_INFO = \"WRONG_INFO\", \n    SOLD = \"SOLD\", \n    VIOLATE = \"VIOLATE\", \n}\n\nexport enum UpdateIntroImagesShopPayloadOperation {\n    UpdateCover = \"updateCover\", \n}\n\nexport interface Payload10 {\n    introImages: string[];\n}\n\nexport enum UpdateLogoImageShopPayloadOperation {\n    UpdateAvatar = \"updateAvatar\", \n}\n\nexport interface Payload11 {\n    logoImage: string;\n}\n\nexport enum DeactivateShopPayloadOperation {\n    Deactivate = \"deactivate\", \n}\n\nexport enum ActivateShopPayloadOperation {\n    Activate = \"activate\", \n}\n\nexport enum UpdateShopPayloadOperation {\n    UpdateDetail = \"updateDetail\", \n}\n\nexport interface Payload12 {\n    domain: string;\n    name: string;\n    address: string;\n    geocode: Geocode3;\n    phone: string;\n    email: string;\n    expiryDate: number;\n}\n\nexport interface Geocode {\n    lng: number;\n    lat: number;\n}\n\nexport interface Geocode2 {\n    lng: number;\n    lat: number;\n}\n\nexport interface Location {\n    isDeleted: boolean;\n    lastModifiedAt: number;\n    _id: string;\n    name: string;\n    slug: string;\n}\n\nexport interface CategoryId {\n    isDeleted: boolean;\n    lastModifiedAt: number;\n    _id: string;\n    name: string;\n    slug: string;\n}\n\nexport interface Brand2 {\n    isDeleted: boolean;\n    lastModifiedAt: number;\n    _id: string;\n    name: string;\n    slug: string;\n    totalNews: number;\n}\n\nexport interface Model2 {\n    isDeleted: boolean;\n    lastModifiedAt: number;\n    _id: string;\n    name: string;\n    slug: string;\n    brand: string;\n    category: string;\n}\n\nexport interface Data2 {\n    title: string;\n    state: string;\n    newsType: string;\n    priceType: string;\n    location: string;\n    owner: string;\n    status: string;\n    usedHours: number;\n    serialNo: string;\n    categoryId: string;\n    type: string;\n    brand: string;\n    model: string;\n    weight: number;\n    year: number;\n}\n\nexport enum UpdateBrandPayloadOperation {\n    UpdateDetail = \"updateDetail\", \n}\n\nexport enum UpdateCategoryPayloadOperation {\n    UdpateDetail = \"udpateDetail\", \n}\n\nexport interface Payload13 {\n    name: string;\n    imageUrl: string;\n}\n\nexport interface Payload14 {\n    userId: string;\n    newsId: string;\n}\n\nexport enum Payload9ResolvedResult {\n    SKIP = \"SKIP\", \n    DELETE = \"DELETE\", \n}\n\nexport enum ReportsReason {\n    WRONG_INFO = \"WRONG_INFO\", \n    SOLD = \"SOLD\", \n    VIOLATE = \"VIOLATE\", \n}\n\nexport interface Geocode3 {\n    lng: number;\n    lat: number;\n}\n\nexport class SwaggerException extends Error {\n    message: string;\n    status: number; \n    response: string; \n    headers: { [key: string]: any; };\n    result: any; \n\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\n        super();\n\n        this.message = message;\n        this.status = status;\n        this.response = response;\n        this.headers = headers;\n        this.result = result;\n    }\n\n    protected isSwaggerException = true;\n\n    static isSwaggerException(obj: any): obj is SwaggerException {\n        return obj.isSwaggerException === true;\n    }\n}\n\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {\n    if(result !== null && result !== undefined)\n        throw result;\n    else\n        throw new SwaggerException(message, status, response, headers, null);\n}","module.exports = require(\"@babel/runtime/regenerator\");","module.exports = require(\"firebase/app\");","module.exports = require(\"firebase/auth\");","module.exports = require(\"isomorphic-fetch\");","module.exports = require(\"react\");","module.exports = require(\"uuid\");"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxFA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAFA;AAGA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAHA;AAhCA;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAFA;AAhBA;;;;;;;;;;;;ACEA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AACA;AACA;AAQA;;;;;;;;;;;;ACRA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAAA;AAAA;AAAA;AACA;AAaA;AACA;AAfA;AAAA;AACA;AADA;AAgBA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9BA;AAAA;AACA;AADA;AA+BA;AACA;AAhCA;AAAA;AAAA;AACA;AADA;AAkCA;AACA;AAnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACHA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AAFA;AAKA;AACA;AACA;AAFA;AAKA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;AC/DA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;;;;;;;;;;;;ACXA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAJA;AAOA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;ACRA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;ACxCA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAEA;AACA;AAKA;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;;;;;;;;;;;;ACFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AApDA;AA6DA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAJA;AAaA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;AA1BA;AACA;AA4BA;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAKA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AACA;AAEA;;;;;;;AAVA;AAAA;AAAA;AAeA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AAhCA;AAAA;AAAA;AAmCA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;AAjEA;AAAA;AAAA;AAqEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAnFA;AAAA;AAAA;AAqFA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAtHA;AAAA;AAAA;AA2HA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA5IA;AAAA;AAAA;AA8IA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;AA3KA;AAAA;AAAA;AA+KA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA7LA;AAAA;AAAA;AA+LA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AA5NA;AAAA;AAAA;AAiOA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAlPA;AAAA;AAAA;AAoPA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AAjRA;AAAA;AAAA;AAuRA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AA5SA;AAAA;AAAA;AA8SA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;;;AA3UA;AAAA;AAAA;AAqVA;AACA;AAAA;AACA;AAIA;AAGA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA3XA;AAAA;AAAA;AA6XA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AA1ZA;AAAA;AAAA;AA+ZA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AAjbA;AAAA;AAAA;AAmbA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;AAhdA;AAAA;AAAA;AAodA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAleA;AAAA;AAAA;AAoeA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAjgBA;AAAA;AAAA;AAsgBA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAvhBA;AAAA;AAAA;AAyhBA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AAtjBA;AAAA;AAAA;AA4jBA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AAhlBA;AAAA;AAAA;AAmlBA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;;;AAjnBA;AAAA;AAAA;AA2nBA;AACA;AAAA;AACA;AAIA;AAGA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAjqBA;AAAA;AAAA;AAmqBA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAhsBA;AAAA;AAAA;AAqsBA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AAvtBA;AAAA;AAAA;AAytBA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AA5vBA;AAAA;AAAA;AAiwBA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAlxBA;AAAA;AAAA;AAoxBA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAjzBA;AAAA;AAAA;AAszBA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAv0BA;AAAA;AAAA;AAy0BA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAt2BA;AAAA;AAAA;AA22BA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA53BA;AAAA;AAAA;AA83BA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AA35BA;AAAA;AAAA;AAi6BA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AAr7BA;AAAA;AAAA;AAw7BA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AAt9BA;AAAA;AAAA;AA49BA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AAh/BA;AAAA;AAAA;AAm/BA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAjhCA;AAAA;AAAA;AAshCA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AAxiCA;AAAA;AAAA;AA0iCA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;AA7kCA;AAAA;AAAA;AAqlCA;AACA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAnnCA;AAAA;AAAA;AAqnCA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AAlpCA;AAAA;AAAA;AAwpCA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AA5qCA;AAAA;AAAA;AA+qCA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;AA7sCA;AAAA;AAAA;AAqtCA;AACA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAnvCA;AAAA;AAAA;AAqvCA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAlxCA;AAAA;AAAA;AAuxCA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AAzyCA;AAAA;AAAA;AA2yCA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AA90CA;AAAA;AAAA;AAo1CA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AAx2CA;AAAA;AAAA;AA22CA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAz4CA;AAAA;AAAA;AA84CA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AAh6CA;AAAA;AAAA;AAk6CA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;AAr8CA;AAAA;AAAA;AAy8CA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAv9CA;AAAA;AAAA;AAy9CA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AAt/CA;AAAA;AAAA;AA4/CA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AAhhDA;AAAA;AAAA;AAmhDA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAjjDA;AAAA;AAAA;AAsjDA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AAxkDA;AAAA;AAAA;AA0kDA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;AA7mDA;AAAA;AAAA;AAinDA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA/nDA;AAAA;AAAA;AAioDA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;AA9pDA;AAAA;AAAA;AAsqDA;AACA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AApsDA;AAAA;AAAA;AAssDA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAnuDA;AAAA;AAAA;AAwuDA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AA1vDA;AAAA;AAAA;AA4vDA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;AA/xDA;AAAA;AAAA;AAuyDA;AACA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAr0DA;AAAA;AAAA;AAu0DA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;;;AAp2DA;AAAA;AAAA;AA82DA;AACA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAp5DA;AAAA;AAAA;AAs5DA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAn7DA;AAAA;AAAA;AAw7DA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAz8DA;AAAA;AAAA;AA28DA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AAx+DA;AAAA;AAAA;AA8+DA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AAlgEA;AAAA;AAAA;AAqgEA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;AAniEA;AAAA;AAAA;AA2iEA;AACA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAzkEA;AAAA;AAAA;AA2kEA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AAxmEA;AAAA;AAAA;AA8mEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AAloEA;AAAA;AAAA;AAqoEA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAnqEA;AAAA;AAAA;AAwqEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAzrEA;AAAA;AAAA;AA2rEA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAxtEA;AAAA;AAAA;AA6tEA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AA/uEA;AAAA;AAAA;AAivEA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;;;;AApxEA;AAAA;AAAA;AA+xEA;AACA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAz0EA;AAAA;AAAA;AA20EA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAx2EA;AAAA;AAAA;AA62EA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA93EA;AAAA;AAAA;AAg4EA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AA75EA;AAAA;AAAA;AAm6EA;AACA;AAAA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAx7EA;AAAA;AAAA;AA07EA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAv9EA;AAAA;AAAA;AA49EA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA7+EA;AAAA;AAAA;AA++EA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AA5gFA;AAAA;AAAA;AAkhFA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AAtiFA;AAAA;AAAA;AAyiFA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAvkFA;AAAA;AAAA;AA4kFA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AA9lFA;AAAA;AAAA;AAgmFA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;;;;AAnoFA;AAAA;AAAA;AA8oFA;AACA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAxrFA;AAAA;AAAA;AA0rFA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAvtFA;AAAA;AAAA;AA4tFA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA7uFA;AAAA;AAAA;AA+uFA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AA5wFA;AAAA;AAAA;AAkxFA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AAtyFA;AAAA;AAAA;AAyyFA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AAv0FA;AAAA;AAAA;AA60FA;AACA;AAAA;AACA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAn2FA;AAAA;AAAA;AAq2FA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;;;AAl4FA;AAAA;AAAA;AA44FA;AACA;AAAA;AACA;AAEA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAj7FA;AAAA;AAAA;AAm7FA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;AAh9FA;AAAA;AAAA;AAo+FA;AACA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAljGA;AAAA;AAAA;AAojGA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAjlGA;AAAA;AAAA;AAslGA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AAxmGA;AAAA;AAAA;AA0mGA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;;AA7oGA;AAAA;AAAA;AAspGA;AACA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAxrGA;AAAA;AAAA;AA0rGA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAvtGA;AAAA;AAAA;AA4tGA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AA9uGA;AAAA;AAAA;AAgvGA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;AAnxGA;AAAA;AAAA;AAuxGA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAryGA;AAAA;AAAA;AAuyGA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAp0GA;AAAA;AAAA;AAy0GA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA11GA;AAAA;AAAA;AA41GA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;AAz3GA;AAAA;AAAA;AA63GA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA34GA;AAAA;AAAA;AA64GA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AA16GA;AAAA;AAAA;AA+6GA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAh8GA;AAAA;AAAA;AAk8GA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AA/9GA;AAAA;AAAA;AAq+GA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AAz/GA;AAAA;AAAA;AA4/GA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;AA1hHA;AAAA;AAAA;AA8hHA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA5iHA;AAAA;AAAA;AA8iHA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AA3kHA;AAAA;AAAA;AAglHA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AAlmHA;AAAA;AAAA;AAomHA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAvoHA;AAAA;AAAA;AA4oHA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA7pHA;AAAA;AAAA;AA+pHA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AA5rHA;AAAA;AAAA;AAisHA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAltHA;AAAA;AAAA;AAotHA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AAjvHA;AAAA;AAAA;AAuvHA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AA3wHA;AAAA;AAAA;AA8wHA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;;;;AA5yHA;AAAA;AAAA;AAuzHA;AACA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAj2HA;AAAA;AAAA;AAm2HA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAh4HA;AAAA;AAAA;AAq4HA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AAv5HA;AAAA;AAAA;AAy5HA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AA57HA;AAAA;AAAA;AAi8HA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAl9HA;AAAA;AAAA;AAo9HA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AAj/HA;AAAA;AAAA;AAu/HA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AA3gIA;AAAA;AAAA;AA8gIA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;AA5iIA;AAAA;AAAA;AAgjIA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA9jIA;AAAA;AAAA;AAgkIA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AA7lIA;AAAA;AAAA;AAkmIA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAHA;AASA;AACA;AACA;AACA;AApnIA;AAAA;AAAA;AAsnIA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAzpIA;AAAA;AAAA;AA8pIA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA/qIA;AAAA;AAAA;AAirIA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AA9sIA;AAAA;AAAA;AAotIA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AAxuIA;AAAA;AAAA;AA2uIA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AAzwIA;AAAA;AAAA;AAgyIA;AACA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AA13IA;AAAA;AAAA;AA43IA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AAz5IA;AAAA;AAAA;AA+5IA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAHA;AAQA;AACA;AACA;AACA;AAn7IA;AAAA;AAAA;AAs7IA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;;;;AAp9IA;AAAA;AAAA;AA+9IA;AACA;AAAA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAOA;AACA;AACA;AACA;AAzgJA;AAAA;AAAA;AA2gJA;AACA;AAAA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAtiJA;AACA;AADA;AAAA;AA+rKA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AADA;AAAA;AAAA;AACA;AASA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AADA;AAAA;AAAA;AACA;AAUA;AACA;AADA;AAAA;AAAA;AACA;AAYA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AADA;AAAA;AAAA;AACA;AAiBA;AACA;AADA;AAAA;AAAA;AACA;AAUA;AACA;AADA;AAAA;AAAA;AACA;AAUA;AACA;AADA;AAAA;AAAA;AACA;AAQA;AACA;AADA;AAAA;AAAA;AACA;AAQA;AACA;AADA;AAAA;AAAA;AACA;AAOA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AADA;AAAA;AAAA;AACA;AAeA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AADA;AAAA;AAAA;AACA;AAOA;AACA;AADA;AAAA;AAAA;AACA;AAOA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AADA;AAAA;AAAA;AACA;AA4EA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AADA;AAAA;AAAA;AACA;AAaA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AAUA;AAAA;AAAA;AAAA;AACA;AAMA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AACA;AAPA;AAQA;AACA;AAhBA;AAAA;AAAA;AAoBA;AACA;AArBA;AACA;AADA;AAAA;AACA;AAuBA;AACA;AAIA;;;;;;;;;;;;;;;;;;;;;;;ACziLA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}